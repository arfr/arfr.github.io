<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ARFR - Alexander Fuhr</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      background: #000000;
      overflow: hidden;
      cursor: grab;
      touch-action: none; /* Prevent browser zoom gestures */
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    body:active {
      cursor: grabbing;
    }

    canvas {
      display: block;
      opacity: 0;
      transition: opacity 3s ease;
    }

    canvas.visible {
      opacity: 1;
    }

    /* ── Message Overlay ── */
    #msg-stack {
      position: fixed;
      top: 20px;
      left: 20px;
      right: 20px;
      z-index: 50;
      display: flex;
      flex-direction: column;
      gap: 8px;
      pointer-events: none;
      font-family: 'Courier New', monospace;
    }

    @media (min-width: 768px) {
      #msg-stack {
        top: 40px;
        left: 40px;
        right: auto;
      }
    }

    .holo-msg {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 8px 14px;
      border: 1px solid rgba(200, 170, 120, 0.0);
      border-radius: 4px;
      background: rgba(0, 0, 0, 0.0);
      color: rgba(240, 210, 160, 0);
      font-size: 9px;
      letter-spacing: 2px;
      text-transform: uppercase;
      white-space: normal;
      word-wrap: break-word;
      transform: translateX(-15px);
      opacity: 0;
      animation: msg-in 0.6s ease-out forwards;
      box-shadow: none;
      backdrop-filter: blur(0px);
      position: relative;
      overflow: hidden;
      will-change: transform, opacity;
    }

    .msg-time {
      flex-shrink: 0;
      opacity: 0.4;
      font-size: 10px;
      min-width: 52px;
      font-family: 'Courier New', monospace;
    }

    .msg-text {
      flex: 1;
      line-height: 1.4;
    }

    @media (min-width: 768px) {
      .holo-msg {
        padding: 10px 22px;
        font-size: 11px;
        letter-spacing: 3px;
        max-width: 500px;
      }
    }

    .holo-msg::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 60%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(240, 210, 160, 0.08), transparent);
      animation: msg-sweep 1.5s ease-out 0.3s forwards;
    }

    .holo-msg::after {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      width: 2px;
      height: 0%;
      background: rgba(240, 210, 160, 0.6);
      box-shadow: 0 0 6px rgba(240, 210, 160, 0.4);
      animation: msg-bar 0.5s ease-out 0.1s forwards;
    }

    @keyframes msg-in {
      0% {
        transform: translateX(-15px);
        opacity: 0;
        border-color: rgba(200, 170, 120, 0);
        background: rgba(0, 0, 0, 0);
        color: rgba(240, 210, 160, 0);
      }

      100% {
        transform: translateX(0);
        opacity: 1;
        border-color: rgba(200, 170, 120, 0.15);
        background: rgba(0, 0, 0, 0.4);
        color: rgba(240, 210, 160, 0.8);
        box-shadow: 0 0 10px rgba(200, 170, 120, 0.05), inset 0 0 15px rgba(200, 170, 120, 0.02);
      }
    }

    @keyframes msg-sweep {
      0% {
        left: -60%;
      }

      100% {
        left: 160%;
      }
    }

    @keyframes msg-bar {
      0% {
        height: 0%;
      }

      100% {
        height: 100%;
      }
    }

    .holo-msg.fade-out {
      animation: msg-out 0.5s ease-in forwards;
    }

    @keyframes msg-out {
      0% {
        transform: translateX(0);
        opacity: 1;
        border-color: rgba(200, 170, 120, 0.15);
        background: rgba(0, 0, 0, 0.4);
        color: rgba(240, 210, 160, 0.8);
        max-height: 80px;
        margin-bottom: 0;
        padding: 8px 14px;
      }

      100% {
        transform: translateX(-10px);
        opacity: 0;
        border-color: rgba(200, 170, 120, 0);
        background: rgba(0, 0, 0, 0);
        color: rgba(240, 210, 160, 0);
        max-height: 0;
        margin-bottom: -8px;
        padding: 0 14px;
        max-height: 0px;
        margin-bottom: -8px;
        padding: 0px 14px;
      }
    }

    /* RUN Button inside loading */
    .run-button {
      position: absolute;
      top: calc(50% + 55px);
      left: 50%;
      transform: translate(-50%, -50%);
      background: transparent;
      border: 1px solid rgba(200, 170, 120, 0.5);
      color: rgba(200, 170, 120, 0.7);
      font-family: 'Courier New', monospace;
      font-size: 12px;
      letter-spacing: 6px;
      padding: 8px 24px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      z-index: 10;
    }
    
    .run-button:hover {
      background: rgba(200, 170, 120, 0.1);
      border-color: rgba(200, 170, 120, 0.8);
      color: rgba(200, 170, 120, 1);
    }
    
    .run-button:active {
      transform: translate(-50%, -50%) scale(0.95);
    }
    
    .run-button.hidden {
      display: none;
    }
    
    .run-button.pulse {
      animation: chat-alert-pulse 2s infinite;
      border-color: rgba(200, 170, 120, 0.6);
    }

    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      font-family: 'Courier New', monospace;
      color: rgba(200, 170, 120, 0.6);
      transition: opacity 1.5s;
    }

    #loading.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #loading .bar {
      width: min(300px, 60vw);
      height: 2px;
      background: rgba(200, 170, 120, 0.15);
      margin-top: 35px;
      position: relative;
      overflow: visible;
    }

    #loading .bar-fill {
      height: 100%;
      background: rgba(200, 170, 120, 0.7);
      width: 0%;
      transition: width 0.4s;
      position: relative;
      box-shadow: 0 0 8px rgba(200, 170, 120, 0.6), 0 0 20px rgba(200, 170, 120, 0.3), 0 0 40px rgba(200, 170, 120, 0.15);
    }

    #loading .bar-fill.hidden {
      display: none;
    }

    #loading .bar-fill::after {
      content: '';
      position: absolute;
      right: -2px;
      top: 50%;
      transform: translateY(-50%);
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: rgba(240, 210, 160, 0.9);
      box-shadow: 0 0 6px 3px rgba(240, 210, 160, 0.8), 0 0 15px 6px rgba(200, 170, 120, 0.5), 0 0 30px 10px rgba(200, 170, 120, 0.25);
      animation: pulse-glow 0.8s ease-in-out infinite alternate;
    }

    @keyframes pulse-glow {
      from {
        box-shadow: 0 0 6px 3px rgba(240, 210, 160, 0.8), 0 0 15px 6px rgba(200, 170, 120, 0.5), 0 0 30px 10px rgba(200, 170, 120, 0.25);
      }

      to {
        box-shadow: 0 0 8px 4px rgba(240, 210, 160, 1), 0 0 20px 8px rgba(200, 170, 120, 0.7), 0 0 45px 15px rgba(200, 170, 120, 0.35);
      }
    }

    /* ── Interactive Elements ── */
    .ripple {
      position: absolute;
      border-radius: 50%;
      border: 2px solid rgba(200, 170, 120, 0.8);
      transform: scale(0);
      animation: ripple-effect 0.6s ease-out forwards;
      pointer-events: none;
      z-index: 1000;
    }

    @keyframes ripple-effect {
      0% { transform: scale(0); opacity: 1; }
      100% { transform: scale(4); opacity: 0; }
    }

    .vessel-hover {
      position: fixed;
      pointer-events: none;
      z-index: 100;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(200, 170, 120, 0.3);
      border-radius: 4px;
      color: rgba(240, 210, 160, 0.9);
      font-family: 'Courier New', monospace;
      font-size: 10px;
      letter-spacing: 1px;
      text-transform: uppercase;
      opacity: 0;
      transform: translateY(10px);
      transition: all 0.3s ease;
      backdrop-filter: blur(8px);
    }

    .vessel-hover.visible {
      opacity: 1;
      transform: translateY(0);
    }

    #loading .text {
      font-size: 28px;
      letter-spacing: 16px;
      text-transform: uppercase;
      padding-left: 16px;
      text-align: center;
	  font-family: 'Orbitron', sans-serif !important;
    }
	
    /* ── Chat Widget ── */
    #chat-trigger {
      position: fixed;
      bottom: 20px;
      left: 87.5%;
      transform: translateX(-50%);
      z-index: 60;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 1px solid rgba(200, 170, 120, 0.3);
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      color: rgba(240, 210, 160, 0.8);
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      box-shadow: 0 0 15px rgba(200, 170, 120, 0.1);
      opacity: 0;
      pointer-events: none;
      font-family: 'Courier New', monospace;
    }

    @media (min-width: 768px) {
      #chat-trigger {
        bottom: 30px;
        width: 50px;
        height: 50px;
        font-size: 22px;
      }
    }

    #chat-trigger.visible {
      opacity: 1;
      pointer-events: all;
    }

    #chat-trigger:hover {
      border-color: rgba(200, 170, 120, 0.6);
      box-shadow: 0 0 25px rgba(200, 170, 120, 0.2), 0 0 50px rgba(200, 170, 120, 0.08);
      transform: translateX(-50%) scale(1.05);
    }

    #chat-trigger.pulse {
      animation: chat-alert-pulse 2s infinite;
      border-color: rgba(200, 170, 120, 0.6);
    }

    @keyframes chat-alert-pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(200, 170, 120, 0.4);
      }

      70% {
        box-shadow: 0 0 0 10px rgba(200, 170, 120, 0);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(200, 170, 120, 0);
      }
    }

    #chat-panel {
      position: fixed;
      bottom: 70px;
      left: 10px;
      right: 10px;
      z-index: 60;
      max-height: 400px;
      border: 1px solid rgba(200, 170, 120, 0.2);
      border-radius: 6px;
      background: rgba(0, 0, 0, 0.45);
      backdrop-filter: blur(12px);
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      opacity: 0;
      transform: translateY(20px) scale(0.95);
      pointer-events: none;
      transition: all 0.4s ease;
      box-shadow: 0 0 30px rgba(200, 170, 120, 0.08), inset 0 0 30px rgba(200, 170, 120, 0.02);
    }

    @media (min-width: 768px) {
      #chat-panel {
        bottom: 90px;
        left: auto;
        right: 30px;
        width: 360px;
        max-height: 480px;
      }
    }

    #chat-panel.open {
      opacity: 1;
      transform: translateY(0) scale(1);
      pointer-events: all;
    }

    #chat-header {
      padding: 14px 18px;
      border-bottom: 1px solid rgba(200, 170, 120, 0.15);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #chat-header span {
      color: rgba(240, 210, 160, 0.7);
      font-size: 11px;
      letter-spacing: 3px;
      text-transform: uppercase;
    }

    #chat-header .status {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: rgba(200, 170, 120, 0.5);
      box-shadow: 0 0 6px rgba(200, 170, 120, 0.4);
      display: inline-block;
      margin-right: 8px;
      animation: status-pulse 2s ease-in-out infinite;
    }

    @keyframes status-pulse {

      0%,
      100% {
        opacity: 0.4;
      }

      50% {
        opacity: 1;
      }
    }

    #chat-close {
      background: none;
      border: none;
      color: rgba(200, 170, 120, 0.4);
      font-size: 18px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      transition: color 0.2s;
    }

    #chat-close:hover {
      color: rgba(240, 210, 160, 0.8);
    }

    #chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 14px 18px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: 320px;
      scrollbar-width: thin;
      scrollbar-color: rgba(200, 170, 120, 0.2) transparent;
    }

    .chat-bubble {
      padding: 8px 14px;
      border-radius: 4px;
      font-size: 11px;
      line-height: 1.5;
      letter-spacing: 0.5px;
      max-width: 85%;
      flex-shrink: 0;
      animation: bubble-in 0.3s ease-out forwards;
      opacity: 0;
      position: relative;
      overflow: hidden;
    }

    .chat-bubble::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 60%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(240, 210, 160, 0.05), transparent);
      animation: msg-sweep 1.2s ease-out 0.2s forwards;
    }

    @keyframes bubble-in {
      from {
        opacity: 0;
        transform: translateY(8px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .chat-user {
      align-self: flex-end;
      background: rgba(200, 170, 120, 0.1);
      border: 1px solid rgba(200, 170, 120, 0.2);
      color: rgba(240, 210, 160, 0.85);
    }

    .chat-bot {
      align-self: flex-start;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(200, 170, 120, 0.1);
      color: rgba(200, 170, 120, 0.7);
    }

    .chat-system {
      align-self: center;
      color: rgba(200, 170, 120, 0.4);
      font-size: 10px;
      letter-spacing: 2px;
      text-transform: uppercase;
      border: none;
      background: none;
    }

    #chat-input-area {
      padding: 12px 14px;
      border-top: 1px solid rgba(200, 170, 120, 0.12);
      display: flex;
      gap: 8px;
    }

    #chat-input {
      flex: 1;
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(200, 170, 120, 0.15);
      border-radius: 3px;
      padding: 8px 12px;
      color: rgba(240, 210, 160, 0.9);
      font-family: 'Courier New', monospace;
      font-size: 12px;
      outline: none;
      transition: border-color 0.2s;
    }

    #chat-input::placeholder {
      color: rgba(200, 170, 120, 0.25);
    }

    #chat-input:focus {
      border-color: rgba(200, 170, 120, 0.4);
    }

    #chat-send {
      background: rgba(200, 170, 120, 0.1);
      border: 1px solid rgba(200, 170, 120, 0.25);
      border-radius: 3px;
      color: rgba(240, 210, 160, 0.7);
      padding: 8px 14px;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      letter-spacing: 1px;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
    }

    #chat-send:hover {
      background: rgba(200, 170, 120, 0.2);
      border-color: rgba(200, 170, 120, 0.5);
      color: rgba(240, 210, 160, 0.9);
    }

    /* ── Info Widget ── */
    #info-trigger {
      position: fixed;
      bottom: 20px;
      left: 12.5%;
      transform: translateX(-50%);
      z-index: 60;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 1px solid rgba(200, 170, 120, 0.3);
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      color: rgba(240, 210, 160, 0.8);
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      box-shadow: 0 0 15px rgba(200, 170, 120, 0.1);
      opacity: 0;
      pointer-events: none;
      font-family: 'Courier New', monospace;
    }

    @media (min-width: 768px) {
      #info-trigger {
        bottom: 30px;
        width: 50px;
        height: 50px;
        font-size: 22px;
      }
    }

    #info-trigger.visible {
      opacity: 1;
      pointer-events: all;
    }

    #info-trigger:hover {
      border-color: rgba(200, 170, 120, 0.6);
      box-shadow: 0 0 25px rgba(200, 170, 120, 0.2), 0 0 50px rgba(200, 170, 120, 0.08);
      transform: translateX(-50%) scale(1.05);
    }

    /* ── Play Widget ── */
    #play-trigger {
      position: fixed;
      bottom: 20px;
      left: calc((25% + 50%) / 2);
      transform: translateX(-50%);
      z-index: 60;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 1px solid rgba(200, 170, 120, 0.3);
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      color: rgba(240, 210, 160, 0.8);
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      box-shadow: 0 0 15px rgba(200, 170, 120, 0.1);
      opacity: 0;
      pointer-events: none;
    }

    @media (max-width: 767px) {
      #play-trigger {
        left: 32%;
        transform: translateX(-50%);
      }
    }

    @media (min-width: 768px) {
      #play-trigger {
        bottom: 30px;
        left: 32%;
        width: 50px;
        height: 50px;
        font-size: 22px;
      }
    }

    #play-trigger.visible {
      opacity: 1;
      pointer-events: all;
    }

    #play-trigger:hover {
      border-color: rgba(200, 170, 120, 0.6);
      box-shadow: 0 0 25px rgba(200, 170, 120, 0.2), 0 0 50px rgba(200, 170, 120, 0.08);
      transform: translateX(-50%) scale(1.05);
    }

    #info-panel {
      position: fixed;
      bottom: 70px;
      left: 10px;
      right: 10px;
      z-index: 60;
      border: 1px solid rgba(200, 170, 120, 0.2);
      border-radius: 6px;
      background: rgba(0, 0, 0, 0.45);
      backdrop-filter: blur(12px);
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      opacity: 0;
      transform: translateY(20px) scale(0.95);
      pointer-events: none;
      transition: all 0.4s ease;
      box-shadow: 0 0 30px rgba(200, 170, 120, 0.08), inset 0 0 30px rgba(200, 170, 120, 0.02);
    }

    @media (min-width: 768px) {
      #info-panel {
        bottom: 90px;
        left: 30px;
        right: auto;
        width: 360px;
      }
    }

    #info-panel.open {
      opacity: 1;
      transform: translateY(0) scale(1);
      pointer-events: all;
    }

    #info-header {
      padding: 14px 18px;
      border-bottom: 1px solid rgba(200, 170, 120, 0.15);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #info-header span {
      color: rgba(240, 210, 160, 0.7);
      font-size: 11px;
      letter-spacing: 3px;
      text-transform: uppercase;
    }

    #info-header .status {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: rgba(200, 170, 120, 0.5);
      box-shadow: 0 0 6px rgba(200, 170, 120, 0.4);
      display: inline-block;
      margin-right: 8px;
      animation: status-pulse 2s ease-in-out infinite;
    }

    #info-close {
      background: none;
      border: none;
      color: rgba(200, 170, 120, 0.4);
      font-size: 18px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      transition: color 0.2s;
    }

    #info-close:hover {
      color: rgba(240, 210, 160, 0.8);
    }

    #info-body {
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    #info-body .info-title {
      color: rgba(240, 210, 160, 0.85);
      font-size: 13px;
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    #info-body .info-role {
      color: rgba(200, 170, 120, 0.5);
      font-size: 10px;
      letter-spacing: 3px;
      text-transform: uppercase;
      margin-top: -8px;
    }

    #info-body .info-quote {
      color: rgba(200, 170, 120, 0.55);
      font-size: 11px;
      line-height: 1.6;
      font-style: italic;
      border-left: 2px solid rgba(200, 170, 120, 0.2);
      padding-left: 12px;
      /* Zusätzlicher Architect-Touch: */
      letter-spacing: 0.03em;
      word-spacing: 0.1em;
    }

    #info-body .info-divider {
      height: 1px;
      background: rgba(200, 170, 120, 0.1);
    }

    #info-body .info-footer {
      color: rgba(200, 170, 120, 0.4);
      font-size: 10px;
      letter-spacing: 1.5px;
      text-align: center;
      line-height: 1.8;
    }

    #info-body .info-footer a {
      color: rgba(240, 210, 160, 0.6);
      text-decoration: none;
      text-transform: uppercase;
      letter-spacing: 2px;
      transition: color 0.2s, text-shadow 0.2s;
    }

    #info-body .info-footer a:hover {
      color: rgba(240, 210, 160, 0.9);
      text-shadow: 0 0 8px rgba(200, 170, 120, 0.3);
    }

    #info-body .info-links {
      display: flex;
      justify-content: center;
      gap: 16px;
      flex-wrap: wrap;
    }

    #info-body .info-links a {
      color: rgba(240, 210, 160, 0.55);
      text-decoration: none;
      font-size: 10px;
      letter-spacing: 2px;
      text-transform: uppercase;
      padding: 4px 8px;
      border: 1px solid rgba(200, 170, 120, 0.12);
      border-radius: 3px;
      transition: all 0.2s;
    }

    #info-body .info-links a:hover {
      color: rgba(240, 210, 160, 0.9);
      border-color: rgba(200, 170, 120, 0.4);
      background: rgba(200, 170, 120, 0.08);
      box-shadow: 0 0 12px rgba(200, 170, 120, 0.1);
    }

    /* ── Rabbit Widget (Matrix Easter Egg) ── */
    #rabbit-trigger {
      position: fixed;
      bottom: 20px;
      left: calc((50% + 75%) / 2);
      transform: translateX(-50%);
      z-index: 60;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 1px solid rgba(200, 170, 120, 0.3);
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      color: rgba(240, 210, 160, 0.8);
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: opacity 0.6s ease, border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
      box-shadow: 0 0 15px rgba(200, 170, 120, 0.1);
      opacity: 0;
      pointer-events: none;
      font-family: 'Courier New', monospace;
    }

    @media (max-width: 767px) {
      #rabbit-trigger {
        left: 69%;
        transform: translateX(-50%);
      }
    }

    @media (min-width: 768px) {
      #rabbit-trigger {
        bottom: 30px;
        left: 69%;
        width: 50px;
        height: 50px;
        font-size: 22px;
      }
    }

    #rabbit-trigger.visible {
      opacity: 1;
      pointer-events: all;
    }

    #rabbit-trigger.ghost {
      opacity: 0;
      pointer-events: none;
    }

    #rabbit-trigger:hover {
      border-color: rgba(100, 255, 140, 0.6);
      box-shadow: 0 0 25px rgba(100, 255, 140, 0.2), 0 0 50px rgba(100, 255, 140, 0.08);
      transform: translateX(-50%) scale(1.1);
    }

    #rabbit-trigger .rabbit-glyph {
      transition: text-shadow 0.3s ease;
    }

    #rabbit-trigger:hover .rabbit-glyph {
      text-shadow: 0 0 8px rgba(100, 255, 140, 0.6);
    }

    /* ── Settings Widget ── */
    #settings-trigger {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 60;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 1px solid rgba(200, 170, 120, 0.3);
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      color: rgba(240, 210, 160, 0.8);
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      box-shadow: 0 0 15px rgba(200, 170, 120, 0.1);
      opacity: 0;
      pointer-events: none;
      font-family: 'Courier New', monospace;
    }

    @media (min-width: 768px) {
      #settings-trigger {
        bottom: 30px;
        width: 50px;
        height: 50px;
        font-size: 22px;
      }
    }

    #settings-trigger.visible {
      opacity: 1;
      pointer-events: all;
    }

    #settings-trigger:hover {
      border-color: rgba(200, 170, 120, 0.6);
      box-shadow: 0 0 25px rgba(200, 170, 120, 0.2);
      transform: translateX(-50%) scale(1.05);
    }

    #settings-panel {
      position: fixed;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%) translateY(20px) scale(0.95);
      z-index: 60;
      width: 300px;
      border: 1px solid rgba(200, 170, 120, 0.2);
      border-radius: 6px;
      background: rgba(0, 0, 0, 0.45);
      backdrop-filter: blur(12px);
      font-family: 'Courier New', monospace;
      overflow: hidden;
      opacity: 0;
      pointer-events: none;
      transition: all 0.4s ease;
      box-shadow: 0 0 30px rgba(200, 170, 120, 0.08), inset 0 0 30px rgba(200, 170, 120, 0.02);
    }

    @media (min-width: 768px) {
      #settings-panel {
        bottom: 90px;
      }
    }

    #settings-panel.open {
      opacity: 1;
      transform: translateX(-50%) translateY(0) scale(1);
      pointer-events: all;
    }

    #settings-panel .s-header {
      padding: 14px 18px;
      border-bottom: 1px solid rgba(200, 170, 120, 0.15);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #settings-panel .s-header span {
      color: rgba(240, 210, 160, 0.7);
      font-size: 11px;
      letter-spacing: 3px;
      text-transform: uppercase;
    }

    #settings-panel .s-close {
      background: none;
      border: none;
      color: rgba(200, 170, 120, 0.4);
      font-size: 18px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      transition: color 0.2s;
    }

    #settings-panel .s-close:hover {
      color: rgba(240, 210, 160, 0.8);
    }

    #settings-panel .s-body {
      padding: 14px 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .setting-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .setting-row label {
      color: rgba(200, 170, 120, 0.6);
      font-size: 10px;
      letter-spacing: 1.5px;
      text-transform: uppercase;
    }

    .setting-toggle {
      width: 36px;
      height: 18px;
      border: 1px solid rgba(200, 170, 120, 0.3);
      border-radius: 9px;
      background: rgba(0, 0, 0, 0.4);
      cursor: pointer;
      position: relative;
      transition: all 0.3s;
    }

    .setting-toggle.on {
      border-color: rgba(200, 170, 120, 0.6);
      background: rgba(200, 170, 120, 0.15);
    }

    .setting-toggle::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: rgba(200, 170, 120, 0.4);
      transition: all 0.3s;
    }

    .setting-toggle.on::after {
      left: 20px;
      background: rgba(240, 210, 160, 0.8);
      box-shadow: 0 0 6px rgba(200, 170, 120, 0.5);
    }

    /* ── Reset Modal ── */
    #reset-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(5px);
      z-index: 200;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
      font-family: 'Courier New', monospace;
    }
	
    #reset-modal.visible {
      opacity: 1;
      pointer-events: all;
    }

    #reset-modal .m-content {
      width: min(360px, 90vw);
      border: 1px solid rgba(200, 170, 120, 0.2);
      border-radius: 12px;
      background: rgba(0, 0, 0, 0.45);
      backdrop-filter: blur(12px);
      box-shadow: 0 0 40px rgba(0, 0, 0, 0.5), inset 0 0 30px rgba(200, 170, 120, 0.05);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      animation: modal-appear 0.4s cubic-bezier(0.16, 1, 0.3, 1);
    }

    @keyframes modal-appear {
      from {
        opacity: 0;
        transform: translateY(10px) scale(0.98);
      }

      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    #reset-modal .m-header {
      padding: 18px 24px;
      border-bottom: 1px solid rgba(200, 170, 120, 0.15);
      display: flex;
      align-items: center;
      color: rgba(240, 210, 160, 0.8);
      font-size: 11px;
      letter-spacing: 3px;
      text-transform: uppercase;
    }

    #reset-modal .status {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: rgba(200, 170, 120, 0.6);
      box-shadow: 0 0 6px rgba(200, 170, 120, 0.4);
      display: inline-block;
      margin-right: 12px;
      animation: status-pulse 2s ease-in-out infinite;
    }

    #reset-modal .m-body {
      padding: 28px 24px;
      color: rgba(200, 170, 120, 0.75);
      font-size: 12px;
      line-height: 1.8;
      letter-spacing: 0.5px;
    }

    #reset-modal .m-footer {
      padding: 0 24px 28px;
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }

    #reset-modal button {
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(200, 170, 120, 0.2);
      border-radius: 4px;
      color: rgba(200, 170, 120, 0.65);
      padding: 12px 22px;
      font-family: inherit;
      font-size: 10px;
      letter-spacing: 2px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      text-transform: uppercase;
    }

    #reset-modal button:hover {
      border-color: rgba(240, 210, 160, 0.5);
      color: rgba(240, 210, 160, 0.95);
      background: rgba(200, 170, 120, 0.12);
      transform: translateY(-1px);
    }

    #reset-confirm {
      border-color: rgba(200, 170, 120, 0.4) !important;
    }

    #reset-confirm:hover {
      background: rgba(200, 170, 120, 0.15) !important;
      border-color: rgba(240, 210, 160, 0.7) !important;
      color: rgba(255, 255, 255, 1.0) !important;
    }

    /* ── Score HUD ── */
    #score-hud {
      position: fixed;
      top: 16px;
      right: 16px;
      z-index: 55;
      font-family: 'Orbitron', 'Courier New', monospace;
      pointer-events: none;
      opacity: 0;
      visibility: hidden;
      transition: opacity 1.5s cubic-bezier(0.25, 0.1, 0.25, 1);
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0;
      background: linear-gradient(135deg, rgba(0,0,0,0.15) 0%, rgba(10,8,4,0.35) 100%);
      border: 1px solid rgba(200, 170, 120, 0.08);
      border-radius: 6px;
      padding: 10px 0;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      box-shadow: 
        0 0 30px rgba(0,0,0,0.4),
        inset 0 0 20px rgba(200, 170, 120, 0.015),
        0 0 1px rgba(200, 170, 120, 0.1);
      overflow: hidden;
    }

    #score-hud::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(240, 210, 160, 0.15), transparent);
    }

    #score-hud::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(240, 210, 160, 0.08), transparent);
    }

    #score-hud.visible {
      opacity: 1;
      visibility: visible;
    }

    .score-row {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 10px;
      padding: 3px 14px 3px 18px;
      position: relative;
      width: 100%;
      box-sizing: border-box;
    }

    .score-row::after {
      content: '';
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 2px;
      background: rgba(200, 170, 120, 0.12);
      box-shadow: 0 0 4px rgba(200, 170, 120, 0.05);
    }

    .score-row.primary {
      padding: 5px 14px 5px 18px;
    }

    .score-row.primary .score-value {
      font-size: 14px;
      color: rgba(240, 210, 160, 0.95);
      text-shadow: 0 0 6px rgba(240, 210, 160, 0.15);
    }

    .score-row.primary::after {
      width: 2px;
      background: rgba(240, 210, 160, 0.25);
      box-shadow: 0 0 6px rgba(240, 210, 160, 0.1);
    }

    .score-label {
      color: rgba(200, 170, 120, 0.3);
      font-size: 7px;
      letter-spacing: 2.5px;
      text-transform: uppercase;
      text-align: right;
    }

    .score-value {
      color: rgba(240, 210, 160, 0.7);
      font-size: 11px;
      letter-spacing: 1px;
      min-width: 36px;
      text-align: right;
      transition: color 0.4s cubic-bezier(0.25, 0.1, 0.25, 1), text-shadow 0.4s cubic-bezier(0.25, 0.1, 0.25, 1);
      font-variant-numeric: tabular-nums;
    }

    .score-value.flash {
      color: rgba(255, 255, 220, 1);
      text-shadow: 0 0 12px rgba(240, 210, 160, 0.9), 0 0 24px rgba(240, 210, 160, 0.3);
    }

    .score-bar-container {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
      padding: 4px 14px 4px 18px;
      width: 100%;
      box-sizing: border-box;
      position: relative;
    }

    .score-bar-container::after {
      content: '';
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 2px;
      background: rgba(200, 170, 120, 0.08);
    }

    .score-bar-track {
      width: 70px;
      height: 2px;
      background: rgba(200, 170, 120, 0.06);
      border-radius: 1px;
      overflow: hidden;
      position: relative;
    }

    .score-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, rgba(200, 170, 120, 0.3), rgba(240, 210, 160, 0.7));
      border-radius: 1px;
      transition: width 0.8s cubic-bezier(0.25, 0.1, 0.25, 1);
      box-shadow: 0 0 6px rgba(240, 210, 160, 0.25);
      position: relative;
    }

    .score-bar-fill::after {
      content: '';
      position: absolute;
      right: 0;
      top: -1px;
      bottom: -1px;
      width: 3px;
      background: rgba(240, 210, 160, 0.9);
      border-radius: 50%;
      box-shadow: 0 0 4px rgba(240, 210, 160, 0.6);
    }

    .score-divider {
      width: 100%;
      height: 1px;
      background: linear-gradient(90deg, transparent 10%, rgba(200, 170, 120, 0.06) 50%, transparent 90%);
      margin: 3px 0;
    }

    @media (min-width: 768px) {
      #score-hud {
        top: 30px;
        right: 30px;
        padding: 12px 0;
      }
      .score-label { font-size: 8px; }
      .score-value { font-size: 12px; }
      .score-row.primary .score-value { font-size: 16px; }
      .score-bar-track { width: 90px; }
    }

    /* Mobile Score HUD - compact and readable */
    @media (max-width: 767px) {
      #score-hud {
        top: 8px;
        right: 8px;
        padding: 6px 0;
        gap: 0;
        background: linear-gradient(135deg, rgba(0,0,0,0.25) 0%, rgba(10,8,4,0.45) 100%);
        border-radius: 4px;
      }
      .score-row {
        gap: 6px;
        padding: 2px 10px 2px 12px;
      }
      .score-row.primary {
        padding: 3px 10px 3px 12px;
      }
      .score-label {
        font-size: 6px;
        letter-spacing: 1.5px;
      }
      .score-value {
        font-size: 9px;
        min-width: 28px;
      }
      .score-row.primary .score-value {
        font-size: 11px;
      }
      .score-bar-container {
        gap: 6px;
        padding: 2px 10px 2px 12px;
      }
      .score-bar-track {
        width: 50px;
        height: 2px;
      }
      .score-divider {
        margin: 2px 0;
      }
    }

  </style>
</head>

<body>
  <div id="loading">
    <div class="text">ARFR CORE</div>
    <div class="bar">
      <button id="run-btn" class="run-button pulse">ENTER</button>
      <div class="bar-fill hidden" id="loadBar"></div>
    </div>
  </div>
  <div id="msg-stack"></div>
  <div id="vessel-tooltip" class="vessel-hover"></div>

  <!-- Score HUD -->
  <div id="score-hud">
    <div class="score-row primary">
      <span class="score-label">Score</span>
      <span class="score-value" id="hud-score">0</span>
    </div>
    <div class="score-row primary">
      <span class="score-label">Level</span>
      <span class="score-value" id="hud-level">0</span>
    </div>
    <div class="score-divider"></div>
    <div class="score-row">
      <span class="score-label">Caught</span>
      <span class="score-value" id="hud-caught">0</span>
    </div>
    <div class="score-row">
      <span class="score-label">Demons</span>
      <span class="score-value" id="hud-demons-killed">0</span>
    </div>
    <div class="score-row">
      <span class="score-label">Cleansed</span>
      <span class="score-value" id="hud-cleansed">0</span>
    </div>
    <div class="score-divider"></div>
    <div class="score-bar-container">
      <span class="score-label">Shield</span>
      <div class="score-bar-track">
        <div class="score-bar-fill" id="hud-shield-bar" style="width: 0%"></div>
      </div>
    </div>
    <div class="score-bar-container">
      <span class="score-label">Vessels</span>
      <div class="score-bar-track">
        <div class="score-bar-fill" id="hud-vessel-bar" style="width: 0%"></div>
      </div>
    </div>
  </div>

  <!-- Chat Widget -->
  <div id="chat-trigger" title="Kommunikationskanal">⟐</div>
  <div id="chat-panel">
    <div id="chat-header">
      <span><span class="status"></span>ARFR COMM CHANNEL</span>
      <button id="chat-close">×</button>
    </div>
    <div id="chat-messages"></div>
    <div id="chat-input-area">
      <input type="text" id="chat-input" placeholder="Enter message..." autocomplete="off">
      <button id="chat-send">SEND</button>
    </div>
  </div>

  <!-- Info Widget -->
  <div id="info-trigger" title="Info"><svg width="22" height="22" viewBox="0 0 24 24" fill="none"
      stroke="rgba(240,210,160,0.8)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" />
      <circle cx="12" cy="12" r="3" />
    </svg></div>
  <div id="info-panel">
    <div id="info-header">
      <span><span class="status"></span>ARFR IDENT</span>
      <button id="info-close">×</button>
    </div>
    <div id="info-body">
      <div class="info-title">Alexander Fuhr</div>
      <div class="info-role">Software Developer</div>
      <div class="info-quote">Building digital systems from the ground up — Architecture · Code · Scalability · AI
      </div>
      <div class="info-divider"></div>
      <div class="info-links">
        <a href="https://www.linkedin.com/in/alexander-fuhr" target="_blank">LinkedIn</a>
        <a href="https://github.com/arfrfrfr" target="_blank">Github</a>
        <a href="https://twitter.com/" target="_blank">Twitter</a>
        <a href="https://xing.com/" target="_blank">XING</a>
      </div>
      <div class="info-footer">© 2026 arfr.de</div>
    </div>
  </div>

  <!-- Play (Game) Trigger -->
  <div id="play-trigger" title="Materia Start/Stop"><svg width="22" height="22" viewBox="0 0 24 24" fill="none"
      stroke="rgba(240,210,160,0.8)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" id="play-icon">
      <polygon points="6.5 3 20.5 12 6.5 21 6.5 3"></polygon>
    </svg>
  </div>

  <!-- Reset Confirmation Modal -->
  <div id="reset-modal">
    <div class="m-content">
      <div class="m-header"><span><span class="status"></span>TERMINATE CORE</span></div>
      <div class="m-body">Are you sure? All Materia progress and vessel alignments will be lost. The system will start
        from zero initialization state.</div>
      <div class="m-footer">
        <button id="reset-cancel">Cancel</button>
        <button id="reset-confirm">Confirm Reset</button>
      </div>
    </div>
  </div>

  <!-- Settings Widget -->
  <div id="settings-trigger" title="Settings"><svg width="20" height="20" viewBox="0 0 24 24" fill="none"
      stroke="rgba(240,210,160,0.8)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="3" />
      <path
        d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z" />
    </svg></div>
  <div id="settings-panel">
    <div class="s-header">
      <span><span class="status"></span>SETTINGS</span>
      <button class="s-close" id="settings-close">×</button>
    </div>
    <div class="s-body">
      <div class="setting-row">
        <label>Auto Camera</label>
        <div class="setting-toggle on" id="toggle-auto-cam"></div>
      </div>
      <div class="setting-row">
        <label>Manual Camera</label>
        <div class="setting-toggle on" id="toggle-manual-cam"></div>
      </div>
      <div class="setting-row">
        <label>Rotation Lock</label>
        <div class="setting-toggle" id="toggle-rotation-lock"></div>
      </div>
    </div>
  </div>

  <!-- Rabbit (Matrix Easter Egg) -->
  <div id="rabbit-trigger" title="Follow the white rabbit">
    <svg width="22" height="22" viewBox="0 0 24 24" fill="none"
      stroke="rgba(240,210,160,0.8)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <!-- Rabbit ears -->
      <path d="M9 2 C8 2 7 4 7.5 7 C7.8 9 9 10 10 10" />
      <path d="M15 2 C16 2 17 4 16.5 7 C16.2 9 15 10 14 10" />
      <!-- Head -->
      <ellipse cx="12" cy="12" rx="4" ry="3.5" />
      <!-- Eyes -->
      <circle cx="10.5" cy="11.5" r="0.5" fill="rgba(240,210,160,0.8)" />
      <circle cx="13.5" cy="11.5" r="0.5" fill="rgba(240,210,160,0.8)" />
      <!-- Nose -->
      <ellipse cx="12" cy="13" rx="0.7" ry="0.4" fill="rgba(240,210,160,0.6)" />
      <!-- Body -->
      <ellipse cx="12" cy="18" rx="3.5" ry="3" />
      <!-- Tail -->
      <circle cx="15" cy="20" r="1" />
      <!-- Feet -->
      <ellipse cx="10" cy="21.5" rx="1.5" ry="0.7" />
      <ellipse cx="14" cy="21.5" rx="1.5" ry="0.7" />
    </svg>
  </div>

  <!-- NoSleep.js for keeping screen awake on mobile -->
  <script src="https://cdn.jsdelivr.net/npm/nosleep.js@0.12.0/dist/NoSleep.min.js"></script>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js';
    // ══════════════════════════════════════════════════════
    //  PALETTE
    // ══════════════════════════════════════════════════════
    const BG = 0x000000;
    const AMBER = 0xc8a878;
    const AMBER_LIGHT = 0xdfc090;
    const CHIP_TONE = 0x1e2a3e;
    const FADE_RADIUS = 35;

    // Global settings (referenced by camera and interaction code)
    window.arfrSettings = {
      autoCam: true,
      manualCam: true,
      rotationLock: false,
      gameActive: false, // Start stopped
      lockedDragX: 0,
      lockedDragY: 0,
    };

    // ── Viewport-Zentrierung: automatisch berechnet ──
    // Wird nach Kamera-Setup berechnet

    // ══════════════════════════════════════════════════════
    //  SCENE
    // ══════════════════════════════════════════════════════
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(BG);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const viewSize = 30;
    const aspect = window.innerWidth / window.innerHeight;
    const SHIFT_X = 10;
    const SHIFT_Y = -28;

    const camera = new THREE.OrthographicCamera(
      -viewSize * aspect + SHIFT_X, viewSize * aspect + SHIFT_X,
      viewSize + SHIFT_Y, -viewSize + SHIFT_Y,
      0.1, 200
    );
    camera.position.set(0, 100, 0);
    camera.rotation.set(-Math.PI / 2, 0, 0);
    camera.zoom = 0.45;
    camera.updateProjectionMatrix();

    // Seeded random for consistent layout
    let seed = 12345;
    function srand() { seed = (seed * 16807 + 0) % 2147483647; return (seed - 1) / 2147483646; }
    function rand(a, b) { return srand() * (b - a) + a; }
    function randInt(a, b) { return Math.floor(rand(a, b)); }
    function pick(arr) { return arr[Math.floor(srand() * arr.length)]; }


    // Lights
    scene.add(new THREE.AmbientLight(0x1a1a1a, 0.3));
    const dirLight = new THREE.DirectionalLight(0xdfc090, 0.8);
    dirLight.position.set(5, 30, 10);
    scene.add(dirLight);
    const coreLight = new THREE.PointLight(AMBER, 2, 40);
    coreLight.position.set(0, 5, 0);
    // coreLight will be added to coreGroup so it follows the chip

    const world = new THREE.Group();
    world.rotation.set(0, 0, 0);
    scene.add(world);

    

    // ══════════════════════════════════════════════════════
    //  INTERACTIVE ELEMENTS
    // ══════════════════════════════════════════════════════
    const tooltip = document.getElementById('vessel-tooltip');
    if (tooltip) tooltip.style.display = 'none';
    let hoveredVessel = null;
    
    // Raycaster for hover detection
    const hoverRaycaster = new THREE.Raycaster();
    const hoverMouse = new THREE.Vector2();
    
    function updateHover(x, y) {
      hoverMouse.x = (x / window.innerWidth) * 2 - 1;
      hoverMouse.y = -(y / window.innerHeight) * 2 + 1;
    }
    
    // Click ripple effect
    function createRipple(x, y) {
      const ripple = document.createElement('div');
      ripple.className = 'ripple';
      ripple.style.left = (x - 10) + 'px';
      ripple.style.top = (y - 10) + 'px';
      ripple.style.width = '20px';
      ripple.style.height = '20px';
      document.body.appendChild(ripple);
      
      setTimeout(() => ripple.remove(), 600);
    }
    
    // Add click listeners for ripple
    document.addEventListener('mousedown', e => {
      if (!isDrag) createRipple(e.clientX, e.clientY);
    });
    document.addEventListener('touchstart', e => {
      if (e.touches[0] && !isDrag) {
        createRipple(e.touches[0].clientX, e.touches[0].clientY);
      }
    }, { passive: true });

    // Drag connection line for vessel transfer - curved arc
    let dragLine = null;
    let arcPoints = [];
    const ARC_SEGMENTS = 20;
    
    function createDragLine() {
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(ARC_SEGMENTS * 3);
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      const material = new THREE.LineBasicMaterial({
        color: 0xe8e0d0,
        transparent: true,
        opacity: 0,
        linewidth: 2
      });
      
      dragLine = new THREE.Line(geometry, material);
      world.add(dragLine);
    }
    createDragLine();

    // ══════════════════════════════════════════════════════
    //  STARFIELD & SHOOTING STARS
    // ══════════════════════════════════════════════════════
    const STAR_COUNT = 600;
    const STAR_SPREAD = 120;
    const starGeo = new THREE.BufferGeometry();
    const starPositions = new Float32Array(STAR_COUNT * 3);
    const starSizes = new Float32Array(STAR_COUNT);
    const starBaseAlpha = new Float32Array(STAR_COUNT);
    const starSpeed = new Float32Array(STAR_COUNT * 3);

    for (let i = 0; i < STAR_COUNT; i++) {
      const i3 = i * 3;
      starPositions[i3] = (Math.random() - 0.5) * STAR_SPREAD;
      starPositions[i3 + 1] = (Math.random() - 0.5) * STAR_SPREAD;
      starPositions[i3 + 2] = (Math.random() - 0.5) * STAR_SPREAD;
      starSizes[i] = 0.5 + Math.random() * 2.0;
      starBaseAlpha[i] = 0.2 + Math.random() * 0.8;
      // Slow drift
      starSpeed[i3] = (Math.random() - 0.5) * 0.003;
      starSpeed[i3 + 1] = (Math.random() - 0.5) * 0.002;
      starSpeed[i3 + 2] = (Math.random() - 0.5) * 0.003;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    starGeo.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));

    const starMat = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uColor: { value: new THREE.Color(0xeeeeee) },
        uOpacity: { value: 0.0 }
      },
      vertexShader: `
        attribute float size;
        uniform float uTime;
        varying float vAlpha;
        void main() {
          vAlpha = 0.3 + 0.7 * abs(sin(uTime * 0.5 + position.x * 3.0 + position.z * 2.0));
          vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = size * (80.0 / -mvPos.z);
          gl_Position = projectionMatrix * mvPos;
        }
      `,
      fragmentShader: `
        uniform vec3 uColor;
        uniform float uOpacity;
        varying float vAlpha;
        void main() {
          float d = length(gl_PointCoord - 0.5) * 2.0;
          float glow = exp(-d * d * 3.0);
          gl_FragColor = vec4(uColor, glow * vAlpha * uOpacity);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
    });

    const starField = new THREE.Points(starGeo, starMat);
    world.add(starField);

    // ── Shooting stars ──
    const shootingStars = [];
    const SHOOT_TRAIL_LEN = 30;

    function spawnShootingStar() {
      const trailGeo = new THREE.BufferGeometry();
      const positions = new Float32Array(SHOOT_TRAIL_LEN * 3);
      const alphas = new Float32Array(SHOOT_TRAIL_LEN);
      trailGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      trailGeo.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));

      const trailMat = new THREE.ShaderMaterial({
        uniforms: { color: { value: new THREE.Color(0xffffff) } },
        vertexShader: `
          attribute float alpha;
          varying float vA;
          void main() {
            vA = alpha;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform vec3 color;
          varying float vA;
          void main() { gl_FragColor = vec4(color, vA); }
        `,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
      });

      const trail = new THREE.Line(trailGeo, trailMat);
      world.add(trail);

      // Random start position on a sphere edge
      const angle = Math.random() * Math.PI * 2;
      const elevation = (Math.random() - 0.5) * 1.2;
      const radius = 50 + Math.random() * 20;
      const x = Math.cos(angle) * radius;
      const y = elevation * radius * 0.3 + (Math.random() - 0.3) * 20;
      const z = Math.sin(angle) * radius;

      // Direction roughly toward center with spread
      const speed = 0.8 + Math.random() * 1.2;
      const dx = (-x / radius + (Math.random() - 0.5) * 0.5) * speed;
      const dy = ((Math.random() - 0.5) * 0.3) * speed;
      const dz = (-z / radius + (Math.random() - 0.5) * 0.5) * speed;

      const ss = {
        trail, trailGeo, positions, alphas,
        x, y, z, dx, dy, dz,
        life: 1.0,
        decay: 0.008 + Math.random() * 0.012,
        headIdx: 0,
      };

      // Init all trail positions to start
      for (let j = 0; j < SHOOT_TRAIL_LEN; j++) {
        positions[j * 3] = x;
        positions[j * 3 + 1] = y;
        positions[j * 3 + 2] = z;
        alphas[j] = 0;
      }

      shootingStars.push(ss);
      return ss;
    }

    function updateShootingStars() {
      for (let i = shootingStars.length - 1; i >= 0; i--) {
        const ss = shootingStars[i];
        ss.x += ss.dx;
        ss.y += ss.dy;
        ss.z += ss.dz;
        ss.life -= ss.decay;

        // Update head position in circular buffer
        const idx = ss.headIdx % SHOOT_TRAIL_LEN;
        ss.positions[idx * 3] = ss.x;
        ss.positions[idx * 3 + 1] = ss.y;
        ss.positions[idx * 3 + 2] = ss.z;
        ss.headIdx++;

        // Update alphas — head is bright, tail fades
        for (let j = 0; j < SHOOT_TRAIL_LEN; j++) {
          const age = (ss.headIdx - j + SHOOT_TRAIL_LEN) % SHOOT_TRAIL_LEN;
          ss.alphas[j] = Math.max(0, ss.life * (1 - age / SHOOT_TRAIL_LEN) * 0.8);
        }

        ss.trailGeo.attributes.position.needsUpdate = true;
        ss.trailGeo.attributes.alpha.needsUpdate = true;

        if (ss.life <= 0) {
          world.remove(ss.trail);
          ss.trailGeo.dispose();
          ss.trail.material.dispose();
          shootingStars.splice(i, 1);
        }
      }

      // Random spawn
      if (Math.random() < 0.006 && shootingStars.length < 4) {
        spawnShootingStar();
      }
    }


    function updateStarField(elapsed) {
      // Fade in stars after scene loads
      starMat.uniforms.uOpacity.value = Math.min(1, Math.max(0, (elapsed - 8) / 6));
      starMat.uniforms.uTime.value = elapsed;

      const pos = starGeo.attributes.position.array;
      for (let i = 0; i < STAR_COUNT; i++) {
        const i3 = i * 3;
        pos[i3] += starSpeed[i3];
        pos[i3 + 1] += starSpeed[i3 + 1];
        pos[i3 + 2] += starSpeed[i3 + 2];
        // Wrap around
        const half = STAR_SPREAD / 2;
        if (pos[i3] > half) pos[i3] = -half;
        if (pos[i3] < -half) pos[i3] = half;
        if (pos[i3 + 1] > half) pos[i3 + 1] = -half;
        if (pos[i3 + 1] < -half) pos[i3 + 1] = half;
        if (pos[i3 + 2] > half) pos[i3 + 2] = -half;
        if (pos[i3 + 2] < -half) pos[i3 + 2] = half;
      }
      starGeo.attributes.position.needsUpdate = true;
    }

    // ══════════════════════════════════════════════════════
    //  MATERIA ORBS — FF7-style energy spheres from core
    // ══════════════════════════════════════════════════════
    const materiaOrbs = [];
    let nextMateriaTime = 60; // first spawn at 60s

    const MATERIA_COLORS = [
      [0.65, 0.25, 1.0],  // Purple
      [0.25, 0.85, 1.0],  // Cyan
      [1.0, 0.25, 0.55],  // Pink
      [0.25, 1.0, 0.55],  // Green
      [1.0, 0.55, 0.25],  // Orange
      [0.3, 0.5, 1.0],    // Blue
      [1.0, 0.85, 0.25],  // Yellow
      [1.0, 0.3, 0.3],    // Red
      [0.5, 1.0, 0.85],   // Teal
      [0.85, 0.25, 1.0],  // Magenta
      [1.0, 0.55, 0.55],  // Rose
      [0.55, 0.85, 1.0],  // Sky Blue
    ];

    // Create a radial gradient canvas for the orb sprite
    function createOrbTexture(r, g, b) {
      const size = 128;
      const canvas = document.createElement('canvas');
      canvas.width = size; canvas.height = size;
      const ctx = canvas.getContext('2d');
      const cx = size / 2, cy = size / 2;

      // Outer soft glow
      const g1 = ctx.createRadialGradient(cx, cy, 0, cx, cy, cx);
      g1.addColorStop(0, `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, 1.0)`);
      g1.addColorStop(0.15, `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, 0.9)`);
      g1.addColorStop(0.3, `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, 0.5)`);
      g1.addColorStop(0.6, `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, 0.15)`);
      g1.addColorStop(1, `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, 0.0)`);
      ctx.fillStyle = g1;
      ctx.fillRect(0, 0, size, size);

      // Hot white center
      const g2 = ctx.createRadialGradient(cx, cy, 0, cx, cy, cx * 0.3);
      g2.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
      g2.addColorStop(0.4, `rgba(${Math.round(Math.min(255, r * 300))}, ${Math.round(Math.min(255, g * 300))}, ${Math.round(Math.min(255, b * 300))}, 0.7)`);
      g2.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = g2;
      ctx.fillRect(0, 0, size, size);

      const tex = new THREE.CanvasTexture(canvas);
      tex.needsUpdate = true;
      return tex;
    }

    // Wispy particle texture for surrounding particles
    function createWispTexture(r, g, b) {
      const size = 64;
      const canvas = document.createElement('canvas');
      canvas.width = size; canvas.height = size;
      const ctx = canvas.getContext('2d');
      const cx = size / 2, cy = size / 2;
      const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, cx);
      grad.addColorStop(0, `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, 0.8)`);
      grad.addColorStop(0.5, `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, 0.2)`);
      grad.addColorStop(1, `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, 0.0)`);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, size, size);
      const tex = new THREE.CanvasTexture(canvas);
      tex.needsUpdate = true;
      return tex;
    }

    function createMateriaOrb() {
      const colArr = MATERIA_COLORS[Math.floor(Math.random() * MATERIA_COLORS.length)];
      const [cr, cg, cb] = colArr;
      const col3 = new THREE.Color(cr, cg, cb);

      const group = new THREE.Group();
      group.position.set(0, 0.5, 0);

      // Main orb glow sprite
      const orbTex = createOrbTexture(cr, cg, cb);
      const orbMat = new THREE.SpriteMaterial({
        map: orbTex,
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });
      const orbSprite = new THREE.Sprite(orbMat);
      orbSprite.scale.set(0.01, 0.01, 1);
      group.add(orbSprite);

      // Secondary larger softer glow
      const glowMat = new THREE.SpriteMaterial({
        map: orbTex,
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        color: col3,
      });
      const glowSprite = new THREE.Sprite(glowMat);
      glowSprite.scale.set(0.01, 0.01, 1);
      group.add(glowSprite);

      // Surrounding wisps / particles
      const wispTex = createWispTexture(cr, cg, cb);
      const WISP_COUNT = 8;
      const wisps = [];
      for (let w = 0; w < WISP_COUNT; w++) {
        const wMat = new THREE.SpriteMaterial({
          map: wispTex,
          transparent: true,
          opacity: 0,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
        });
        const wSprite = new THREE.Sprite(wMat);
        wSprite.scale.set(0.3, 0.3, 1);
        group.add(wSprite);
        wisps.push({
          sprite: wSprite, mat: wMat,
          angle: (w / WISP_COUNT) * Math.PI * 2,
          radius: 0.3 + Math.random() * 0.3,
          speed: 0.8 + Math.random() * 1.5,
          yOff: (Math.random() - 0.5) * 0.4,
          phase: Math.random() * Math.PI * 2,
        });
      }

      // Point light
      const light = new THREE.PointLight(col3, 0, 6);
      group.add(light);

      coreGroup.add(group);

      // Full 3D direction vector for "spitting out" in all directions
      const phi = Math.acos(Math.random()); // 0 to PI/2 (Upper hemisphere only)
      const theta = Math.random() * Math.PI * 2;   // 0 to 2PI
      const dirScale = 0.018 + Math.random() * 0.012;
      const speed = 0.25 + Math.random() * 0.35;
      const trajectoryType = Math.floor(Math.random() * 5);

      const orb = {
        group, orbSprite, orbMat, glowSprite, glowMat, wisps, light,
        orbTex, wispTex,
        phase: 'forming',
        age: 0,
        formDuration: 5,
        riseDuration: 4,
        driftDuration: 14,
        fadeDuration: 5,
        baseAngle: theta,
        speed: speed,
        trajectoryType: trajectoryType,
        // Spiral params
        spiralSpeed: 0.3 + Math.random() * 0.8,
        spiralRadius: 0.005 + Math.random() * 0.01,
        // Arc params
        arcHeight: 0.02 + Math.random() * 0.03,
        arcLateral: (Math.random() - 0.5) * 0.02,
        // Zigzag params
        zigFreq: 2 + Math.random() * 3,
        zigAmp: 0.008 + Math.random() * 0.012,
        // S-curve params
        sCurveFreq: 0.4 + Math.random() * 0.6,
        sCurveAmp: 0.01 + Math.random() * 0.015,
        // Base direction (Full 3D)
        dx: Math.sin(phi) * Math.cos(theta) * dirScale,
        dy: Math.cos(phi) * dirScale,
        dz: Math.sin(phi) * Math.sin(theta) * dirScale,
        color: col3,
        movedToWorld: false,
      };

      materiaOrbs.push(orb);
    }

    function updateMateriaOrbs(dt) {
      for (let i = materiaOrbs.length - 1; i >= 0; i--) {
        const orb = materiaOrbs[i];
        orb.age += dt;
        const a = orb.age;
        let opacity = 0;
        let orbSize = 1;
        let glowSize = 1;

        if (orb.phase === 'forming') {
          const t = Math.min(1, a / orb.formDuration);
          if (t >= 1) { orb.phase = 'rising'; orb.age = 0; continue; }
          const smooth = t * t * (3 - 2 * t);
          opacity = smooth;
          orbSize = 0.6 + smooth * 0.8;
          glowSize = 0.4 + smooth * 1.2;
          // Pulsing during formation
          const pulse = 1 + Math.sin(a * 6) * 0.2 * (1 - smooth);
          orbSize *= pulse;
          glowSize *= pulse;
        } else if (orb.phase === 'rising') {
          const t = Math.min(1, a / orb.riseDuration);
          if (t >= 1) {
            orb.phase = 'drifting'; orb.age = 0;
            // Move to world space for free movement
            if (!orb.movedToWorld) {
              orb.movedToWorld = true;
              // Get actual world position before reparenting
              const wp = new THREE.Vector3();
              orb.group.updateWorldMatrix(true, false);
              wp.setFromMatrixPosition(orb.group.matrixWorld);
              coreGroup.remove(orb.group);
              // Convert world pos to world-group local pos
              world.updateWorldMatrix(true, false);
              const invWorld = new THREE.Matrix4().copy(world.matrixWorld).invert();
              wp.applyMatrix4(invWorld);
              orb.group.position.copy(wp);
              world.add(orb.group);
            }
            continue;
          }
          const smooth = t * t * (3 - 2 * t);
          opacity = 1;
          orbSize = 1.4 + smooth * 0.3;
          glowSize = 1.6 + smooth * 0.4;
          // Initial ejection along the random 3D vector
          const ejectBoost = (1 + smooth) * 0.8;
          orb.group.position.x += orb.dx * ejectBoost;
          orb.group.position.y += orb.dy * ejectBoost;
          orb.group.position.z += orb.dz * ejectBoost;
          // Slight wobble
          orb.group.position.x += Math.sin(a * 2) * 0.001;
          orb.group.position.z += Math.cos(a * 1.7) * 0.001;
          // Gentle breathing
          const breath = 1 + Math.sin(a * 3) * 0.08;
          orbSize *= breath;
          glowSize *= breath;
        } else if (orb.phase === 'drifting') {
          const t = Math.min(1, a / orb.driftDuration);
          if (t >= 1) { orb.phase = 'fading'; orb.age = 0; continue; }
          opacity = 1;
          orbSize = 1.7 + t * 0.4;
          glowSize = 2.0 + t * 0.5;

          // Full 3D vector movement (non-linear — decelerates)
          const speedMul = (1 - t * 0.6);
          orb.group.position.x += orb.dx * speedMul;
          orb.group.position.y += orb.dy * speedMul;
          orb.group.position.z += orb.dz * speedMul;

          // Trajectory-specific movement
          const tt = orb.trajectoryType;
          if (tt === 0) {
            // Spiral: orbits outward in a widening spiral
            const spiralAngle = orb.baseAngle + a * orb.spiralSpeed;
            const r = orb.spiralRadius * (1 + a * 0.3);
            orb.group.position.x += Math.cos(spiralAngle) * r;
            orb.group.position.z += Math.sin(spiralAngle) * r;
          } else if (tt === 1) {
            // Arc/parabolic: curves to one side with varying height
            orb.group.position.x += orb.dx + orb.arcLateral * Math.sin(t * Math.PI);
            orb.group.position.z += orb.dz;
            orb.group.position.y += orb.arcHeight * Math.sin(t * Math.PI) * (1 - t);
          } else if (tt === 2) {
            // Zigzag: moves outward with sharp lateral oscillation
            orb.group.position.x += orb.dx;
            orb.group.position.z += orb.dz;
            const zig = Math.sin(a * orb.zigFreq) * orb.zigAmp;
            orb.group.position.x += Math.cos(orb.baseAngle + Math.PI / 2) * zig;
            orb.group.position.z += Math.sin(orb.baseAngle + Math.PI / 2) * zig;
          } else if (tt === 3) {
            // Lazy S-curve: gentle sweeping curves
            const sOffset = Math.sin(a * orb.sCurveFreq) * orb.sCurveAmp;
            orb.group.position.x += orb.dx + Math.cos(orb.baseAngle + Math.PI / 2) * sOffset;
            orb.group.position.z += orb.dz + Math.sin(orb.baseAngle + Math.PI / 2) * sOffset;
            orb.group.position.y += Math.sin(a * 0.7) * 0.003;
          } else {
            // Orbit-drift: slowly orbits around center while drifting outward
            const orbitAngle = orb.baseAngle + a * 0.15;
            const outward = 0.005 * (1 + t);
            orb.group.position.x += Math.cos(orbitAngle) * outward;
            orb.group.position.z += Math.sin(orbitAngle) * outward;
            orb.group.position.y += Math.sin(a * 0.5) * 0.004;
          }

          const breath = 1 + Math.sin(a * 2.5) * 0.06;
          orbSize *= breath;
          glowSize *= breath;
        } else if (orb.phase === 'fading') {
          const t = Math.min(1, a / orb.fadeDuration);
          if (t >= 1) {
            if (orb.group.parent) orb.group.parent.remove(orb.group);
            orb.orbMat.dispose(); orb.glowMat.dispose();
            orb.orbTex.dispose(); orb.wispTex.dispose();
            orb.wisps.forEach(w => w.mat.dispose());
            materiaOrbs.splice(i, 1);
            continue;
          }
          const smooth = t * t * (3 - 2 * t);
          opacity = 1 - smooth;
          orbSize = 2.1 + smooth * 0.8;
          glowSize = 2.5 + smooth * 1.0;
          // Continue last trajectory direction but slower
          const slowdown = 0.3 * (1 - smooth);
          const tt = orb.trajectoryType;
          if (tt === 0) {
            const spiralAngle = orb.baseAngle + (orb.driftDuration + a) * orb.spiralSpeed;
            orb.group.position.x += Math.cos(spiralAngle) * orb.spiralRadius * slowdown;
            orb.group.position.z += Math.sin(spiralAngle) * orb.spiralRadius * slowdown;
          } else {
            orb.group.position.x += orb.dx * slowdown;
            orb.group.position.z += orb.dz * slowdown;
          }
          orb.group.position.y += orb.dy * 0.15 * (1 - smooth);
        }

        // Apply sizes and opacity
        orb.orbSprite.scale.set(orbSize, orbSize, 1);
        orb.glowSprite.scale.set(glowSize * 1.8, glowSize * 1.8, 1);
        orb.orbMat.opacity = opacity * 0.85;
        orb.glowMat.opacity = opacity * 0.25;
        orb.light.intensity = opacity * 2.0;

        // Animate wisps orbiting the orb
        for (const w of orb.wisps) {
          const wAngle = w.angle + a * w.speed;
          const wR = w.radius * orbSize * 0.7;
          w.sprite.position.set(
            Math.cos(wAngle) * wR,
            w.yOff * orbSize * 0.5 + Math.sin(a * 1.5 + w.phase) * 0.1,
            Math.sin(wAngle) * wR
          );
          const wScale = 0.15 + Math.sin(a * 2 + w.phase) * 0.05;
          w.sprite.scale.set(wScale * orbSize, wScale * orbSize, 1);
          w.mat.opacity = opacity * (0.3 + Math.sin(a * 3 + w.phase) * 0.2);
        }
      }
    }

    // ══════════════════════════════════════════════════════
    //  MATERIA VESSELS — collect caught materia by color
    // ══════════════════════════════════════════════════════
    const materiaVessels = {}; // key: "r,g,b" → { group, orbs: count, ... }
    const VESSEL_RADIUS = 12; // distance from center to place vessels
    let vesselCount = 0;

    function getColorKey(col3) {
      return `${col3.r.toFixed(2)},${col3.g.toFixed(2)},${col3.b.toFixed(2)}`;
    }

    function createVesselTexture(r, g, b) {
      const size = 128;
      const canvas = document.createElement('canvas');
      canvas.width = size; canvas.height = size;
      const ctx = canvas.getContext('2d');
      const cx = size / 2, cy = size / 2;
      // Soft vessel glow
      const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, cx);
      grad.addColorStop(0, `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, 0.6)`);
      grad.addColorStop(0.25, `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, 0.3)`);
      grad.addColorStop(0.5, `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, 0.1)`);
      grad.addColorStop(1, `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, 0.0)`);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, size, size);
      // Ring
      ctx.globalCompositeOperation = 'lighter';
      ctx.strokeStyle = `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, 0.4)`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(cx, cy, cx * 0.55, 0, Math.PI * 2);
      ctx.stroke();
      const tex = new THREE.CanvasTexture(canvas);
      tex.needsUpdate = true;
      return tex;
    }

    function createMiniOrbTex(r, g, b) {
      const size = 64;
      const canvas = document.createElement('canvas');
      canvas.width = size; canvas.height = size;
      const ctx = canvas.getContext('2d');
      const cx = size / 2, cy = size / 2;
      const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, cx);
      grad.addColorStop(0, `rgba(255, 255, 255, 1)`);
      grad.addColorStop(0.2, `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, 0.9)`);
      grad.addColorStop(0.6, `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, 0.3)`);
      grad.addColorStop(1, `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, 0.0)`);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, size, size);
      const tex = new THREE.CanvasTexture(canvas);
      tex.needsUpdate = true;
      return tex;
    }

    function getOrCreateVessel(col3) {
      const key = getColorKey(col3);
      if (materiaVessels[key]) return materiaVessels[key];

      // Place vessels in a clock-like circle around the core
      // First vessel caught = position 1 (30° clockwise from top)
      // Then 2, 3, 4... clockwise, last vessel at position 12 (top)
      const angleStep = (Math.PI * 2) / 12;
      // Position 1 = -π/2 + π/6 = -π/3 (30° from top)
      const vAngle = vesselCount * angleStep - Math.PI / 3;
      vesselCount++;

      const group = new THREE.Group();
      const px = Math.cos(vAngle) * VESSEL_RADIUS;
      const pz = Math.sin(vAngle) * VESSEL_RADIUS;
      group.position.set(px, 1.5 + blastLevel * 4, pz);

      // Vessel base glow
      const vesselTex = createVesselTexture(col3.r, col3.g, col3.b);
      const baseMat = new THREE.SpriteMaterial({
        map: vesselTex,
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });
      const baseSprite = new THREE.Sprite(baseMat);
      baseSprite.scale.set(3, 3, 1);
      group.add(baseSprite);

      // Vessel ring (3D torus)
      const ringGeo = new THREE.TorusGeometry(0.8, 0.03, 8, 32);
      const ringMat = new THREE.MeshBasicMaterial({
        color: col3,
        transparent: true,
        opacity: 0,
        depthWrite: false,
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.rotation.x = Math.PI / 2;
      group.add(ring);

      // Second ring tilted
      const ring2 = new THREE.Mesh(
        new THREE.TorusGeometry(0.6, 0.02, 8, 32),
        new THREE.MeshBasicMaterial({ color: col3, transparent: true, opacity: 0, depthWrite: false })
      );
      ring2.rotation.x = Math.PI / 2 + 0.3;
      ring2.rotation.z = 0.5;
      group.add(ring2);

      // Point light
      const vLight = new THREE.PointLight(col3, 0, 5);
      group.add(vLight);

      world.add(group);

      const vessel = {
        group, baseMat, baseSprite, ring, ringMat, ring2,
        ring2Mat: ring2.material, vLight, vesselTex,
        color: col3, key,
        count: 0,
        miniOrbs: [],
        miniOrbTex: createMiniOrbTex(col3.r, col3.g, col3.b),
        fadeIn: 0,
        px, pz,
        corrupted: false,
        shielded: false,
        shieldSprite: null,
        demonCount: 0,
      };

      materiaVessels[key] = vessel;
      return vessel;
    }

    function addMiniOrbToVessel(vessel) {
      vessel.count++;
      const idx = vessel.count - 1;
      const miniMat = new THREE.SpriteMaterial({
        map: vessel.miniOrbTex,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });
      const mini = new THREE.Sprite(miniMat);
      mini.scale.set(0.35, 0.35, 1);

      // Arrange in a small cluster
      const mAngle = idx * 2.4; // golden angle spread
      const mRadius = 0.15 + (idx * 0.08);
      const mY = (Math.random() - 0.5) * 0.3;
      mini.position.set(
        Math.cos(mAngle) * mRadius,
        mY,
        Math.sin(mAngle) * mRadius
      );
      vessel.group.add(mini);
      vessel.miniOrbs.push({ sprite: mini, mat: miniMat, angle: mAngle, radius: mRadius, baseY: mY });
    }

    function updateVessels(elapsed) {
      for (const key in materiaVessels) {
        const v = materiaVessels[key];

        // Smooth movement to target Y position (for level-up transitions)
        if (v._targetY !== undefined) {
          const vdy = v._targetY - v.group.position.y;
          if (Math.abs(vdy) > 0.001) {
            v.group.position.y += vdy * 0.05; // smooth transition
          }
        }

        // Always keep vessels alive, dim when empty (but NOT corrupted ones)
        if (v.corrupted) {
          v.fadeIn = Math.min(1, v.fadeIn + 0.02);
        } else if (v.count <= 0) {
          v.fadeIn = Math.max(0.15, v.fadeIn - 0.005); // dim but never fully gone
        } else if (v.fadeIn < 1) {
          v.fadeIn = Math.min(1, v.fadeIn + 0.01);
        }

        const f = v.fadeIn * v.fadeIn * (3 - 2 * v.fadeIn);

        // Corrupted vessels get boosted opacity
        if (v.corrupted) {
          const cPulse = 0.7 + Math.sin(elapsed * 6) * 0.2;
          v.baseMat.opacity = cPulse;
          v.ringMat.opacity = cPulse * 0.8;
          v.ring2Mat.opacity = cPulse * 0.6;
          v.vLight.intensity = 2.0 + Math.sin(elapsed * 8) * 0.8;
        } else {
          v.baseMat.opacity = f * 0.5;
          v.ringMat.opacity = f * 0.4;
          v.ring2Mat.opacity = f * 0.3;
          v.vLight.intensity = f * 0.8;
        }

        // Rotate rings slowly
        v.ring.rotation.z += 0.003;
        v.ring2.rotation.z -= 0.005;

        // Selection & Hover Pulse
        if (v === selectedVessel) {
          const sPulse = 1.0 + Math.sin(elapsed * 12) * 0.15;
          v.group.scale.set(sPulse, sPulse, sPulse);
          v.vLight.intensity = f * (1.5 + Math.sin(elapsed * 12) * 0.8);
          v.baseMat.opacity = f * (0.6 + Math.sin(elapsed * 12) * 0.3);
        } else if (v === hoveredVessel) {
          const hPulse = 1.0 + Math.sin(elapsed * 18) * 0.12;
          v.group.scale.set(hPulse, hPulse, hPulse);
          v.vLight.intensity = f * 2.5;
          v.baseMat.opacity = f * 0.8;
          v.ringMat.opacity = f * 0.8;
        } else if (selectedVessel) {
          // Dim other potential targets
          v.group.scale.set(1, 1, 1);
          v.baseMat.opacity = f * 0.2;
          v.vLight.intensity = f * 0.3;
        } else {
          v.group.scale.set(1, 1, 1);
        }

        // Bob mini orbs
        for (const mo of v.miniOrbs) {
          mo.sprite.position.y = mo.baseY + Math.sin(elapsed * 2 + mo.angle) * 0.08;
          mo.mat.opacity = f * (0.6 + Math.sin(elapsed * 3 + mo.angle * 2) * 0.2);
        }

        // Shield indicator
        if (v.shielded && v.shieldSprite) {
          v.shieldSprite.material.opacity = f * (0.3 + Math.sin(elapsed * 2) * 0.1);
          const ss = 3.5 + Math.sin(elapsed * 1.5) * 0.2;
          v.shieldSprite.scale.set(ss, ss, 1);
        }

        // Lightning effects for corrupted vessels
        if (v.corrupted && v.lightnings && Math.random() > 0.4) {
          v.lightnings.forEach(l => {
            const pos = l.posArr;
            l.line.material.opacity = 0.3 + Math.random() * 0.5;
            l.line.material.color.setHSL(0.75 + Math.random() * 0.1, 0.8, 0.6 + Math.random() * 0.4);
            for (let v = 0; v < 5; v++) {
              const i3 = v * 3;
              pos[i3] = (Math.random() - 0.5) * 2.5;
              pos[i3 + 1] = (Math.random() - 0.5) * 2.5;
              pos[i3 + 2] = (Math.random() - 0.5) * 2.5;
            }
            l.line.geometry.attributes.position.needsUpdate = true;
          });
        }
      }
    }

    // ── CATCH ANIMATION ──
    const catchAnimations = [];

    function catchMateria(orb) {
      const vessel = getOrCreateVessel(orb.color);

      // Get current world position of orb
      const orbWorldPos = new THREE.Vector3();
      orb.group.updateWorldMatrix(true, false);
      orbWorldPos.setFromMatrixPosition(orb.group.matrixWorld);

      // Get vessel world position
      const vesselWorldPos = new THREE.Vector3();
      vessel.group.updateWorldMatrix(true, false);
      vesselWorldPos.setFromMatrixPosition(vessel.group.matrixWorld);

      // Convert orb pos to world-local
      const worldInv = new THREE.Matrix4().copy(world.matrixWorld).invert();
      const startPos = orbWorldPos.clone().applyMatrix4(worldInv);
      const endPos = new THREE.Vector3(vessel.px, 1.5 + blastLevel * 4, vessel.pz);

      // Create catch trail sprite
      const catchMat = new THREE.SpriteMaterial({
        map: orb.orbTex,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });
      const catchSprite = new THREE.Sprite(catchMat);
      catchSprite.scale.set(1.2, 1.2, 1);
      catchSprite.position.copy(startPos);
      world.add(catchSprite);

      // Remove original orb
      if (orb.group.parent) orb.group.parent.remove(orb.group);
      orb.orbMat.dispose(); orb.glowMat.dispose();
      orb.wisps.forEach(w => w.mat.dispose());
      const orbIdx = materiaOrbs.indexOf(orb);
      if (orbIdx >= 0) materiaOrbs.splice(orbIdx, 1);

      catchAnimations.push({
        sprite: catchSprite, mat: catchMat,
        startPos: startPos.clone(),
        endPos,
        vessel,
        age: 0,
        duration: 1.5,
        tex: orb.orbTex,
        wispTex: orb.wispTex,
      });
    }

    function updateCatchAnimations() {
      for (let i = catchAnimations.length - 1; i >= 0; i--) {
        const ca = catchAnimations[i];
        ca.age += 1 / 60;
        const t = Math.min(1, ca.age / ca.duration);
        const smooth = t * t * (3 - 2 * t);

        // Arc path — rises up then curves to vessel
        const mid = ca.startPos.clone().lerp(ca.endPos, 0.5);
        mid.y += 3; // arc height
        // Quadratic bezier
        const p0 = ca.startPos;
        const p1 = mid;
        const p2 = ca.endPos;
        const inv = 1 - smooth;
        ca.sprite.position.set(
          inv * inv * p0.x + 2 * inv * smooth * p1.x + smooth * smooth * p2.x,
          inv * inv * p0.y + 2 * inv * smooth * p1.y + smooth * smooth * p2.y,
          inv * inv * p0.z + 2 * inv * smooth * p1.z + smooth * smooth * p2.z
        );

        // Shrink and fade toward end
        const s = 1.2 * (1 - smooth * 0.7);
        ca.sprite.scale.set(s, s, 1);
        ca.mat.opacity = 0.9 * (1 - smooth * smooth);

        if (t >= 1) {
          world.remove(ca.sprite);
          ca.mat.dispose();
          ca.tex.dispose();
          ca.wispTex.dispose();
          // Don't add materia to corrupted vessels
          if (!ca.vessel.corrupted) {
            addMiniOrbToVessel(ca.vessel);
            materiaCaught++;
            addScore(SCORE_CATCH, 'catch');
            playSound('catch');
          }
          catchAnimations.splice(i, 1);
        }
      }
    }

    // ── RAYCASTER for catching materia ──
    const raycaster = new THREE.Raycaster();
    const mouseVec = new THREE.Vector2();
    let clickStartPos = { x: 0, y: 0 };

    function onPointerDown(e) {
      const cx = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
      const cy = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
      clickStartPos = { x: cx, y: cy };
    }

    function onPointerUp(e) {
      const cx = e.clientX || (e.changedTouches && e.changedTouches[0] ? e.changedTouches[0].clientX : 0);
      const cy = e.clientY || (e.changedTouches && e.changedTouches[0] ? e.changedTouches[0].clientY : 0);

      // Only count as click if not dragged
      const dist = Math.sqrt((cx - clickStartPos.x) ** 2 + (cy - clickStartPos.y) ** 2);
      if (dist > 10) return;

      mouseVec.x = (cx / window.innerWidth) * 2 - 1;
      mouseVec.y = -(cy / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouseVec, camera);

      // 1. Check demons first (click to convert to angel)
      for (const demon of demons) {
        if (demon.converted) continue;
        const hits = raycaster.intersectObjects([demon.orbSprite, demon.auraSprite], false);
        if (hits.length > 0) {
          convertToAngel(demon);
          return;
        }
      }

      // 2. Check materia orbs (click to catch)
      for (const orb of materiaOrbs) {
        if (orb.phase === 'fading' && orb.age > orb.fadeDuration * 0.8) continue;
        const targets = [orb.orbSprite, orb.glowSprite];
        const hits = raycaster.intersectObjects(targets, false);
        if (hits.length > 0) {
          catchMateria(orb);
          return;
        }
      }

      // 3. Check vessels (click for transfer system)
      for (const key in materiaVessels) {
        const v = materiaVessels[key];
        const hits = raycaster.intersectObjects([v.baseSprite, v.ring], false);
        if (hits.length > 0) {
          if (selectedVessel === null) {
            // Select source vessel (needs ≥3 to decouple)
            if (v.count >= 3 && !v.corrupted) {
              selectedVessel = v;
              // Visual feedback - brighten
              v.vLight.intensity = 3;
              
            }
          } else {
            // Target vessel selected
            console.log('[TRANSFER] Target selected:', key);
            startVesselTransfer(selectedVessel, v);
          }
          return;
        }
      }

      // Click on empty space deselects
      if (selectedVessel) {
        selectedVessel.vLight.intensity = selectedVessel.fadeIn * 0.8;
        selectedVessel = null;
        return;
      }

      // 4. Check logo toggle (only when NOT in play mode)
      if (!window.arfrSettings.gameActive) {
        const logoHits = raycaster.intersectObjects([chipMesh, logoGroup], true);
        if (logoHits.length > 0) {
          // Count logo clicks and show play button after 3 clicks
          logoClickCount++;
          if (logoClickCount >= LOGO_CLICKS_REQUIRED && !playTrigger.classList.contains('visible')) {
            playTrigger.classList.add('visible');
            console.log('[CORE] Play button unlocked after 3 logo clicks');
          }
          
          logoRotationRequest = !logoRotationRequest;
          const state = logoRotationRequest ? "RE-ENGAGED" : "HALTED";
          console.log(`[CORE STATUS] Rotation ${state}`);
          return;
        }
      }
    }

    // Prevent ghost clicks on mobile - track touch events
    let lastTouchTime = 0;
    const GHOST_CLICK_THRESHOLD = 500; // ms to ignore clicks after touch

    document.addEventListener('touchstart', () => { lastTouchTime = Date.now(); }, { passive: true });

    document.addEventListener('mousedown', (e) => {
      // Ignore mouse events if they came from a recent touch (ghost click)
      if (Date.now() - lastTouchTime < GHOST_CLICK_THRESHOLD) return;
      onPointerDown(e);
    });
    document.addEventListener('mouseup', (e) => {
      if (Date.now() - lastTouchTime < GHOST_CLICK_THRESHOLD) return;
      onPointerUp(e);
    });
    document.addEventListener('touchstart', onPointerDown, { passive: true });
    document.addEventListener('touchend', onPointerUp, { passive: true });

    // ══════════════════════════════════════════════════════
    //  ARCHETYP — Connection beams & energy release
    // ══════════════════════════════════════════════════════
    const archetypBeams = {}; // key → { line, mat, ... }
    let archetypState = 'idle'; // idle | slowdown | charge | blast | recover
    let archetypAge = 0;
    let archetypSpeedOverride = null; // if set, overrides generator speed
    const ARCHETYP_SLOWDOWN_SEC = 4;
    const ARCHETYP_CHARGE_SEC = 3;
    const ARCHETYP_BLAST_SEC = 2.5;
    const ARCHETYP_RECOVER_SEC = 4;
    let archetypBlastIntensity = 0; // 0-1, drives the flash

    // Blast beam projectile
    let blastBeam = null;

    function createBlastBeam() {
      const group = new THREE.Group();
      const baseY = 0.5 + blastLevel * 4; // Start at current chip level
      group.position.set(0, 0, 0);

      // Vertical laser beam using a tall narrow sprite column
      const BEAM_SEGMENTS = 80;
      const beamSprites = [];
      const beamTex = createOrbTexture(1, 0.92, 0.65);
      for (let i = 0; i < BEAM_SEGMENTS; i++) {
        const bMat = new THREE.SpriteMaterial({
          map: beamTex, transparent: true, opacity: 0,
          blending: THREE.AdditiveBlending, depthWrite: false,
        });
        const bSprite = new THREE.Sprite(bMat);
        bSprite.scale.set(1.5, 1.5, 1);
        bSprite.position.set(0, baseY + i * 1.2, 0);
        bSprite.visible = false;
        group.add(bSprite);
        beamSprites.push({ sprite: bSprite, mat: bMat, baseY: baseY + i * 1.2 });
      }

      // Core glow at base
      const coreTex = createOrbTexture(1, 1, 1);
      const coreM = new THREE.SpriteMaterial({
        map: coreTex, transparent: true, opacity: 0,
        blending: THREE.AdditiveBlending, depthWrite: false,
      });
      const coreS = new THREE.Sprite(coreM);
      coreS.scale.set(5, 5, 1);
      coreS.position.y = baseY;
      group.add(coreS);

      const bLight = new THREE.PointLight(0xf0d2a0, 0, 30);
      bLight.position.y = baseY;
      group.add(bLight);

      world.add(group);

      return {
        group, beamSprites, beamTex, coreS, coreM, coreTex, bLight,
        frontIdx: 0, age: 0, phase: 'fire', // fire | trail_fade
      };
    }

    function updateBlastBeam(dt) {
      if (!blastBeam) return;
      const bb = blastBeam;
      bb.age += dt;

      if (bb.phase === 'fire') {
        // Rapidly reveal beam segments from bottom to top
        const speed = 4; // segments per frame
        for (let s = 0; s < speed && bb.frontIdx < bb.beamSprites.length; s++) {
          const seg = bb.beamSprites[bb.frontIdx];
          seg.sprite.visible = true;
          seg.mat.opacity = 1;
          const sc = 2.5 - (bb.frontIdx / bb.beamSprites.length) * 1.5;
          seg.sprite.scale.set(sc, sc, 1);
          bb.frontIdx++;
        }

        // Core glow
        bb.coreM.opacity = Math.min(1, bb.age * 3);
        bb.bLight.intensity = Math.min(6, bb.age * 8);

        // Fade trailing segments
        for (let i = 0; i < bb.frontIdx; i++) {
          const seg = bb.beamSprites[i];
          const distFromFront = bb.frontIdx - i;
          if (distFromFront > 15) {
            seg.mat.opacity = Math.max(0, seg.mat.opacity - 0.03);
          }
        }

        if (bb.frontIdx >= bb.beamSprites.length) {
          bb.phase = 'trail_fade';
          bb.age = 0;
        }
      }

      if (bb.phase === 'trail_fade') {
        let allGone = true;
        // Fade from bottom to top
        for (let i = 0; i < bb.beamSprites.length; i++) {
          const seg = bb.beamSprites[i];
          if (!seg.sprite.visible) continue;
          const fadeSpeed = 0.02 + (i / bb.beamSprites.length) * 0.01;
          seg.mat.opacity = Math.max(0, seg.mat.opacity - fadeSpeed);
          if (seg.mat.opacity > 0.01) allGone = false;
          else seg.sprite.visible = false;
        }
        bb.coreM.opacity = Math.max(0, bb.coreM.opacity - 0.02);
        bb.bLight.intensity = Math.max(0, bb.bLight.intensity - 0.1);

        if (allGone) {
          world.remove(bb.group);
          bb.beamTex.dispose(); bb.coreM.dispose(); bb.coreTex.dispose();
          bb.beamSprites.forEach(s => s.mat.dispose());
          blastBeam = null;
        }
      }
    }

    function createBeamTexture(r, g, b) {
      const size = 64;
      const canvas = document.createElement('canvas');
      canvas.width = size; canvas.height = 4;
      const ctx = canvas.getContext('2d');
      const grad = ctx.createLinearGradient(0, 0, 0, 4);
      grad.addColorStop(0, `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, 0)`);
      grad.addColorStop(0.5, `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, 1)`);
      grad.addColorStop(1, `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, 0)`);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, size, 4);
      const tex = new THREE.CanvasTexture(canvas);
      tex.needsUpdate = true;
      return tex;
    }

    function getOrCreateBeam(vessel) {
      const key = vessel.key;
      if (archetypBeams[key]) return archetypBeams[key];

      const col = vessel.color;
      const levelY = blastLevel * 4;
      // Line from vessel to core
      const points = [
        new THREE.Vector3(vessel.px, 1.5 + levelY, vessel.pz),
        new THREE.Vector3(0, 0.5 + levelY, 0)
      ];
      const geo = new THREE.BufferGeometry().setFromPoints(points);
      const mat = new THREE.LineBasicMaterial({
        color: col,
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });
      const line = new THREE.Line(geo, mat);
      world.add(line);

      // Pulse sprite that travels along beam
      const pulseTex = createMiniOrbTex(col.r, col.g, col.b);
      const pulseMat = new THREE.SpriteMaterial({
        map: pulseTex,
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });
      const pulseSprite = new THREE.Sprite(pulseMat);
      pulseSprite.scale.set(0.6, 0.6, 1);
      world.add(pulseSprite);

      const beam = {
        line, geo, mat, pulseSprite, pulseMat, pulseTex,
        vessel, active: false, opacity: 0,
        pulseT: 0, // 0→1 travels from vessel to core
        startPos: new THREE.Vector3(vessel.px, 1.5 + levelY, vessel.pz),
        endPos: new THREE.Vector3(0, 0.5 + levelY, 0),
      };
      archetypBeams[key] = beam;
      return beam;
    }

    function removeBeam(key) {
      const beam = archetypBeams[key];
      if (!beam) return;
      world.remove(beam.line);
      world.remove(beam.pulseSprite);
      beam.mat.dispose(); beam.geo.dispose();
      beam.pulseMat.dispose(); beam.pulseTex.dispose();
      delete archetypBeams[key];
    }

    function updateArchetypBeams(elapsed) {
      const levelY = blastLevel * 4;

      // Check which vessels qualify (≥3 materia AND not corrupted)
      for (const key in materiaVessels) {
        const v = materiaVessels[key];
        if (v.count >= 3 && !v.corrupted) {
          const beam = getOrCreateBeam(v);
          beam.active = true;
        } else {
          if (archetypBeams[key]) archetypBeams[key].active = false;
        }
      }

      // Update beams
      for (const key in archetypBeams) {
        const b = archetypBeams[key];

        // Dynamically update Y positions to match current blast level
        b.startPos.y = 1.5 + levelY;
        b.endPos.y = 0.5 + levelY;

        // Update line geometry to match
        const posArr = b.geo.attributes.position.array;
        posArr[1] = b.startPos.y; // start Y
        posArr[4] = b.endPos.y;   // end Y
        b.geo.attributes.position.needsUpdate = true;

        // Fade in/out
        if (b.active) {
          b.opacity = Math.min(1, b.opacity + 0.015);
        } else {
          b.opacity = Math.max(0, b.opacity - 0.02);
        }

        const pulseOpacity = b.opacity * (0.3 + Math.sin(elapsed * 4 + b.vessel.px) * 0.15);
        b.mat.opacity = pulseOpacity;

        // Pulse sprite travels along beam
        b.pulseT += 0.008;
        if (b.pulseT > 1) b.pulseT = 0;
        const pt = b.pulseT;
        b.pulseSprite.position.lerpVectors(b.startPos, b.endPos, pt);
        b.pulseMat.opacity = b.opacity * 0.7 * Math.sin(pt * Math.PI); // bright in middle
        const ps = 0.4 + Math.sin(pt * Math.PI) * 0.3;
        b.pulseSprite.scale.set(ps, ps, 1);
      }
    }

    // Check if all vessels have at least 3 materia and none corrupted
    function checkAllVesselsFilled() {
      const vessels = Object.values(materiaVessels);
      if (vessels.length < 12) return false;
      return vessels.every(v => v.count >= 3 && !v.corrupted);
    }

    function triggerArchetypEvent() {
      if (archetypState !== 'idle') return;
      if (doomState !== 'idle') return; // Don't trigger archetyp during doom
      archetypState = 'slowdown';
      archetypAge = 0;
      archetypBlastIntensity = 0;
      playSound('fill');
    }

    // ══════════════════════════════════════════════════════
    //  VICTORY — Level 10 reached! Spectacular ending
    // ══════════════════════════════════════════════════════
    let victoryState = 'idle'; // idle | spiral | nova | message
    let victoryAge = 0;
    let victoryParticles = [];
    const VICTORY_SPIRAL_SEC = 10;
    const VICTORY_NOVA_SEC = 6;
    const VICTORY_MSG_SEC = 12;

    function triggerVictory() {
      if (victoryState !== 'idle') return;
      victoryState = 'spiral';
      victoryAge = 0;
      // Fade out shield on victory
      if (globalShield && !globalShield.fadingOut) {
        globalShield.fadingOut = true;
        globalShield.fadeOutAge = 0;
      }
      console.log('[VICTORY] LEVEL 10 REACHED — SPECTACULAR FINALE!');
    }

    function createVictoryParticle(x, y, z, col) {
      const tex = createOrbTexture(col.r, col.g, col.b);
      const mat = new THREE.SpriteMaterial({
        map: tex, transparent: true, opacity: 0.9,
        blending: THREE.AdditiveBlending, depthWrite: false,
      });
      const sprite = new THREE.Sprite(mat);
      sprite.position.set(x, y, z);
      sprite.scale.set(0.3 + Math.random() * 0.5, 0.3 + Math.random() * 0.5, 1);
      world.add(sprite);
      return {
        sprite, mat, tex,
        vx: (Math.random() - 0.5) * 0.3,
        vy: Math.random() * 0.15 + 0.05,
        vz: (Math.random() - 0.5) * 0.3,
        life: 1.0,
        decay: 0.003 + Math.random() * 0.005,
        col,
      };
    }

    function updateVictory(dt, elapsed) {
      if (victoryState === 'idle') return;
      victoryAge += dt;

      if (victoryState === 'spiral') {
        const t = Math.min(1, victoryAge / VICTORY_SPIRAL_SEC);
        const smooth = t * t * (3 - 2 * t);

        // Vessels spiral upward in a magnificent helix
        const vessels = Object.values(materiaVessels);
        for (let vi = 0; vi < vessels.length; vi++) {
          const v = vessels[vi];
          const spiralAngle = elapsed * 0.8 + (vi / vessels.length) * Math.PI * 2;
          const spiralR = 12 * (1 - smooth * 0.5);
          v.group.position.x += (Math.cos(spiralAngle) * spiralR - v.group.position.x) * 0.02;
          v.group.position.z += (Math.sin(spiralAngle) * spiralR - v.group.position.z) * 0.02;
          v.group.position.y += smooth * 0.05;
          v.vLight.intensity = 2 + Math.sin(elapsed * 4 + vi) * 1;
          if (Math.random() < 0.15) {
            victoryParticles.push(createVictoryParticle(
              v.group.position.x, v.group.position.y, v.group.position.z, v.color));
          }
        }

        // Cinematic camera
        world.rotation.x = -0.3 - smooth * 0.2;
        world.rotation.y = elapsed * 0.3;
        camera.zoom = 0.9 + smooth * 0.2;
        camera.updateProjectionMatrix();
        archetypSpeedOverride = 1 + smooth * 3;
        coreLight.intensity = 1 + smooth * 4;

        if (t >= 1) { victoryState = 'nova'; victoryAge = 0; }

      } else if (victoryState === 'nova') {
        const t = Math.min(1, victoryAge / VICTORY_NOVA_SEC);
        const smooth = t * t * (3 - 2 * t);

        const vessels = Object.values(materiaVessels);
        for (let vi = 0; vi < vessels.length; vi++) {
          const v = vessels[vi];
          v.group.position.x *= (1 - smooth * 0.05);
          v.group.position.z *= (1 - smooth * 0.05);
          const sc = 1 + smooth * 2;
          v.group.scale.set(sc, sc, sc);
          v.vLight.intensity = 3 + smooth * 8;
          if (Math.random() < 0.3 + smooth * 0.5) {
            victoryParticles.push(createVictoryParticle(
              v.group.position.x + (Math.random() - 0.5) * 3,
              v.group.position.y + (Math.random() - 0.5) * 3,
              v.group.position.z + (Math.random() - 0.5) * 3, v.color));
          }
        }

        coreLight.intensity = 2 + smooth * 15;
        archetypBlastIntensity = smooth * 5;
        camera.zoom = 1.1 - smooth * 0.4;
        camera.updateProjectionMatrix();

        if (t >= 1) {
          victoryState = 'message'; victoryAge = 0;
          for (const key in materiaVessels) { world.remove(materiaVessels[key].group); }
          for (const key in materiaVessels) delete materiaVessels[key];
          for (const d of demons) world.remove(d.group);
          demons.length = 0;
          removeGlobalShield();

          const overlay = document.createElement('div');
          overlay.id = 'victory-overlay';
          overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0);z-index:9999;display:flex;align-items:center;justify-content:center;flex-direction:column;padding:30px;transition:background 4s ease;';
          const titleEl = document.createElement('div');
          titleEl.style.cssText = 'font-family:Courier New,monospace;color:rgba(255,240,200,0);font-size:42px;letter-spacing:12px;text-transform:uppercase;text-align:center;line-height:1.6;transition:color 3s ease;';
          titleEl.textContent = 'ASCENSION COMPLETE';
          overlay.appendChild(titleEl);
          const subEl = document.createElement('div');
          subEl.style.cssText = 'font-family:Courier New,monospace;color:rgba(200,170,120,0);font-size:18px;letter-spacing:5px;text-transform:uppercase;text-align:center;line-height:2.2;margin-top:30px;max-width:700px;transition:color 4s ease 1.5s;';
          subEl.textContent = 'Zehn Ebenen. Zehn Prüfungen. Das Licht hat jede einzelne gemeistert. Du hast bewiesen, dass keine Dunkelheit dem standhält, der vertraut. Das Spiel ist vorbei — aber die Reise geht weiter.';
          overlay.appendChild(subEl);
          const creditEl = document.createElement('div');
          creditEl.style.cssText = 'font-family:Courier New,monospace;color:rgba(150,130,90,0);font-size:12px;letter-spacing:4px;text-transform:uppercase;text-align:center;margin-top:50px;transition:color 5s ease 3s;';
          creditEl.textContent = 'ARFR.DE — 2026';
          overlay.appendChild(creditEl);
          document.body.appendChild(overlay);
          requestAnimationFrame(() => { requestAnimationFrame(() => {
            overlay.style.background = 'rgba(0,0,0,0.85)';
            titleEl.style.color = 'rgba(255,240,200,0.95)';
            subEl.style.color = 'rgba(200,170,120,0.8)';
            creditEl.style.color = 'rgba(150,130,90,0.6)';
          }); });
        }

      } else if (victoryState === 'message') {
        const t = Math.min(1, victoryAge / VICTORY_MSG_SEC);
        sceneDarkness = Math.min(0.8, t * 0.8);
        if (t > 0.85) {
          const overlay = document.getElementById('victory-overlay');
          if (overlay) overlay.style.opacity = String(1 - (t - 0.85) / 0.15);
        }
        if (t >= 1) { window.location.reload(); return; }
      }

      // Update victory particles
      for (let i = victoryParticles.length - 1; i >= 0; i--) {
        const p = victoryParticles[i];
        p.sprite.position.x += p.vx; p.sprite.position.y += p.vy; p.sprite.position.z += p.vz;
        p.vy *= 0.99; p.vx *= 0.995; p.vz *= 0.995;
        p.life -= p.decay; p.mat.opacity = p.life * 0.8;
        const sc = 0.3 + (1 - p.life) * 0.6;
        p.sprite.scale.set(sc, sc, 1);
        if (p.life <= 0) { world.remove(p.sprite); p.mat.dispose(); p.tex.dispose(); victoryParticles.splice(i, 1); }
      }
    }

    // ══════════════════════════════════════════════════════
    //  DOOM RITUAL — when ALL vessels are corrupted
    // ══════════════════════════════════════════════════════
    let doomState = 'idle'; // idle | connecting | pulsing | draining | ritual | blackout | message | captivity | archangels_enter | archangels_battle | healing | archangels_leave
    let doomAge = 0;
    let doomLines = []; // beams connecting vessels
    let doomIntensity = 0; // master intensity 0→1
    let sceneDarkness = 0; // 0 = normal, 1 = fully dark
    let doomRitualParticles = [];
    let doomVortexAngle = 0;
    let doomShockwave = null;
    let archangels = []; // archangel entities
    let captivityDemons = []; // demons surrounding the chip in captivity

    const DOOM_CONNECT_SEC = 4;
    const DOOM_PULSE_SEC = 5;
    const DOOM_DRAIN_SEC = 6;
    const DOOM_RITUAL_SEC = 8;
    const DOOM_BLACKOUT_SEC = 5;
    const DOOM_MESSAGE_SEC = 10;
    const DOOM_CAPTIVITY_SEC = 5;
    const DOOM_ARCH_ENTER_SEC = 5;
    const DOOM_ARCH_BATTLE_SEC = 8;
    const DOOM_HEALING_SEC = 6;
    const DOOM_ARCH_LEAVE_SEC = 5;

    function checkAllVesselsCorrupted() {
      const vessels = Object.values(materiaVessels);
      if (vessels.length < 12) return false; // ALL 12 vessels must exist
      return vessels.every(v => v.corrupted);
    }

    function triggerDoomRitual() {
      if (doomState !== 'idle') return;
      doomState = 'connecting';
      doomAge = 0;
      doomIntensity = 0;
      sceneDarkness = 0;
      removeGlobalShield(); // Shield can't save from doom
      playSound('doom');

      // Create beams connecting all corrupted vessels to each other
      const vessels = Object.values(materiaVessels);
      const beamY = 1.5 + blastLevel * 4;
      for (let i = 0; i < vessels.length; i++) {
        for (let j = i + 1; j < vessels.length; j++) {
          const v1 = vessels[i];
          const v2 = vessels[j];
          const points = [
            new THREE.Vector3(v1.px, beamY, v1.pz),
            new THREE.Vector3(v2.px, beamY, v2.pz)
          ];
          const geo = new THREE.BufferGeometry().setFromPoints(points);
          const mat = new THREE.LineBasicMaterial({
            color: 0xcc44ff, transparent: true, opacity: 0,
            blending: THREE.AdditiveBlending, depthWrite: false,
          });
          const line = new THREE.Line(geo, mat);
          world.add(line);
          doomLines.push({ line, geo, mat, v1, v2 });
        }
      }
    }

    function createDoomParticle(x, y, z, targetX, targetY, targetZ) {
      const tex = createOrbTexture(0.6, 0.1, 0.9);
      const mat = new THREE.SpriteMaterial({
        map: tex, transparent: true, opacity: 0.8,
        blending: THREE.AdditiveBlending, depthWrite: false,
      });
      const sprite = new THREE.Sprite(mat);
      const sc = 0.3 + Math.random() * 0.5;
      sprite.scale.set(sc, sc, 1);
      sprite.position.set(x, y, z);
      world.add(sprite);
      return {
        sprite, mat, tex,
        x, y, z,
        tx: targetX, ty: targetY, tz: targetZ,
        speed: 0.005 + Math.random() * 0.015,
        wobble: Math.random() * Math.PI * 2,
        wobbleSpeed: 2 + Math.random() * 3,
        wobbleAmp: 0.3 + Math.random() * 0.8,
        life: 1,
      };
    }

    function cleanupDoomRitual() {
      // Remove doom lines
      for (const dl of doomLines) {
        world.remove(dl.line);
        dl.mat.dispose(); dl.geo.dispose();
      }
      doomLines = [];

      // Remove doom particles
      for (const dp of doomRitualParticles) {
        world.remove(dp.sprite);
        dp.mat.dispose(); dp.tex.dispose();
      }
      doomRitualParticles = [];

      // Remove shockwave
      if (doomShockwave) {
        world.remove(doomShockwave.sprite);
        doomShockwave.mat.dispose(); doomShockwave.tex.dispose();
        doomShockwave = null;
      }

      // Remove captivity demons
      for (const cd of captivityDemons) {
        if (cd.group.parent) {
          world.remove(cd.group);
          cd.orbMat.dispose(); cd.auraMat.dispose(); cd.orbTex.dispose();
          cd.lightnings.forEach(l => {
            cd.group.remove(l.line); l.line.geometry.dispose(); l.line.material.dispose();
          });
        }
      }
      captivityDemons = [];

      // Remove archangels
      for (const a of archangels) {
        if (a.group.parent) {
          world.remove(a.group);
          a.orbMat.dispose(); a.auraMat.dispose(); a.wingMat.dispose();
          a.orbTex.dispose(); a.auraTex.dispose(); a.wingTex.dispose();
        }
      }
      archangels = [];
    }

    function updateDoomRitual(dt, elapsed) {
      if (doomState === 'idle') return;
      doomAge += dt;

      if (doomState === 'connecting') {
        // Phase 1: Beams appear between all corrupted vessels
        const t = Math.min(1, doomAge / DOOM_CONNECT_SEC);
        const smooth = t * t * (3 - 2 * t);

        // Fade in doom beams
        for (const dl of doomLines) {
          dl.mat.opacity = smooth * 0.6;
          dl.mat.color.setHSL(0.78 + Math.sin(elapsed * 4) * 0.05, 0.9, 0.5 + smooth * 0.2);
        }

        // Vessels start pulsing brighter and synchronized
        for (const key in materiaVessels) {
          const v = materiaVessels[key];
          if (!v.corrupted) continue;
          const syncPulse = 0.8 + Math.sin(elapsed * 4) * 0.2;
          v.baseMat.opacity = syncPulse * (0.7 + smooth * 0.3);
          v.vLight.intensity = 2.5 + smooth * 2.0 + Math.sin(elapsed * 6) * 1.0;
          v.vLight.color.setHSL(0.78, 0.9, 0.5 + smooth * 0.3);
        }

        // Start slowing the chip
        archetypSpeedOverride = 0.8 * (1 - smooth * 0.3);

        if (t >= 1) {
          doomState = 'pulsing';
          doomAge = 0;
          console.log('[DOOM] Vessels connected — pulsing phase');
        }

      } else if (doomState === 'pulsing') {
        // Phase 2: Everything pulses in unison, growing stronger
        const t = Math.min(1, doomAge / DOOM_PULSE_SEC);
        const smooth = t * t * (3 - 2 * t);
        doomIntensity = smooth;

        // Vessels pulse with increasing intensity
        const pulseFreq = 4 + smooth * 8; // accelerating pulse
        const pulseAmp = 0.3 + smooth * 0.5;
        for (const key in materiaVessels) {
          const v = materiaVessels[key];
          if (!v.corrupted) continue;
          const syncPulse = 1.0 + Math.sin(elapsed * pulseFreq) * pulseAmp;
          v.baseMat.opacity = syncPulse;
          v.ringMat.opacity = syncPulse * 0.8;
          v.vLight.intensity = 3.0 + smooth * 4.0 + Math.sin(elapsed * pulseFreq) * 2.0;
          
          // Scale vessels with pulse
          const sc = 1 + Math.sin(elapsed * pulseFreq) * 0.15 * (1 + smooth);
          v.group.scale.set(sc, sc, sc);
        }

        // Doom beams pulse too
        for (const dl of doomLines) {
          const beamPulse = 0.4 + Math.sin(elapsed * pulseFreq + 0.5) * 0.3;
          dl.mat.opacity = beamPulse + smooth * 0.3;
          dl.mat.color.setHSL(0.78 + Math.sin(elapsed * 2) * 0.05, 0.9, 0.4 + beamPulse * 0.4);
        }

        // Chip slows more
        archetypSpeedOverride = 0.56 * (1 - smooth * 0.5);

        // Scene starts darkening
        sceneDarkness = smooth * 0.3;

        if (t >= 1) {
          doomState = 'draining';
          doomAge = 0;
          console.log('[DOOM] Pulsing complete — draining energy from chip');
        }

      } else if (doomState === 'draining') {
        // Phase 3: Chip loses energy, traces die, darkness falls
        const t = Math.min(1, doomAge / DOOM_DRAIN_SEC);
        const smooth = t * t * (3 - 2 * t);
        doomIntensity = 1;

        // Chip grinds to a halt
        archetypSpeedOverride = 0.28 * (1 - smooth);

        // Deep darkness
        sceneDarkness = 0.3 + smooth * 0.65;

        // Vessels still pulse but now with menacing deep color
        for (const key in materiaVessels) {
          const v = materiaVessels[key];
          if (!v.corrupted) continue;
          const dreadPulse = 0.8 + Math.sin(elapsed * 8) * 0.2;
          v.baseMat.opacity = dreadPulse;
          v.baseMat.color.setHSL(0.78, 0.9, 0.3 + Math.sin(elapsed * 6) * 0.15);
          v.vLight.intensity = 3.0 + Math.sin(elapsed * 8) * 2.0;
        }

        // Doom beams intensify
        for (const dl of doomLines) {
          dl.mat.opacity = 0.6 + Math.sin(elapsed * 6) * 0.2;
        }

        // Spawn particles from vessels toward center
        if (Math.random() < 0.3 + smooth * 0.5) {
          const vessels = Object.values(materiaVessels);
          const rv = vessels[Math.floor(Math.random() * vessels.length)];
          const particleY = (1.5 + blastLevel * 4) + (Math.random() - 0.5) * 2;
          const p = createDoomParticle(
            rv.px + (Math.random() - 0.5) * 2,
            particleY,
            rv.pz + (Math.random() - 0.5) * 2,
            0, 0.5 + blastLevel * 4, 0
          );
          doomRitualParticles.push(p);
        }

        if (t >= 1) {
          doomState = 'ritual';
          doomAge = 0;
          console.log('[DOOM] Energy drained — THE RITUAL BEGINS');
        }

      } else if (doomState === 'ritual') {
        // Phase 4: The destructive ritual
        const t = Math.min(1, doomAge / DOOM_RITUAL_SEC);
        const smooth = t * t * (3 - 2 * t);

        // Chip is dead
        archetypSpeedOverride = 0;

        // Maximum darkness
        sceneDarkness = 0.95;

        // Vortex rotation accelerates
        doomVortexAngle += (0.01 + smooth * 0.08);

        // Vessels orbit and converge toward center
        const vessels = Object.values(materiaVessels);
        for (let vi = 0; vi < vessels.length; vi++) {
          const v = vessels[vi];
          if (!v.corrupted) continue;

          // Pull vessels toward center over time
          const pullStrength = smooth * 0.4;
          const origX = v.px;
          const origZ = v.pz;
          const currentX = origX * (1 - pullStrength);
          const currentZ = origZ * (1 - pullStrength);

          // Add vortex rotation
          const vAngle = doomVortexAngle + (vi / vessels.length) * Math.PI * 2;
          const vRadius = Math.sqrt(currentX * currentX + currentZ * currentZ);
          const finalX = Math.cos(vAngle) * vRadius * (1 - smooth * 0.3);
          const finalZ = Math.sin(vAngle) * vRadius * (1 - smooth * 0.3);

          v.group.position.x = finalX;
          v.group.position.z = finalZ;
          v.group.position.y = (1.5 + blastLevel * 4) + Math.sin(elapsed * 4 + vi) * 0.5 * (1 - smooth);

          // Intense pulsing
          const ritualPulse = 0.5 + Math.sin(elapsed * 12 + vi * 0.7) * 0.5;
          v.baseMat.opacity = ritualPulse;
          v.vLight.intensity = 4.0 + ritualPulse * 4.0;
          v.vLight.color.setHSL(0.78 + Math.sin(elapsed * 3) * 0.08, 1, 0.5);

          // Scale down as they converge
          const sc = 1.0 - smooth * 0.5;
          v.group.scale.set(sc, sc, sc);
        }

        // Doom beams follow vessel positions (update geometry)
        for (const dl of doomLines) {
          const p1 = dl.v1.group.position;
          const p2 = dl.v2.group.position;
          const posArr = dl.geo.attributes.position.array;
          posArr[0] = p1.x; posArr[1] = p1.y; posArr[2] = p1.z;
          posArr[3] = p2.x; posArr[4] = p2.y; posArr[5] = p2.z;
          dl.geo.attributes.position.needsUpdate = true;
          dl.mat.opacity = 0.5 + Math.sin(elapsed * 10) * 0.3;
          dl.mat.color.setHSL(0.78, 1, 0.4 + Math.sin(elapsed * 8) * 0.3);
        }

        // Many particles swirling toward center
        if (Math.random() < 0.6) {
          const angle = Math.random() * Math.PI * 2;
          const radius = 8 + Math.random() * 6;
          const particleY = (0.5 + blastLevel * 4) + Math.random() * 3;
          const p = createDoomParticle(
            Math.cos(angle) * radius,
            particleY,
            Math.sin(angle) * radius,
            0, 0.5 + blastLevel * 4, 0
          );
          doomRitualParticles.push(p);
        }

        // At the climax, create shockwave
        if (smooth > 0.85 && !doomShockwave) {
          const swTex = createOrbTexture(0.7, 0.15, 1.0);
          const swMat = new THREE.SpriteMaterial({
            map: swTex, transparent: true, opacity: 0.8,
            blending: THREE.AdditiveBlending, depthWrite: false,
          });
          const swSprite = new THREE.Sprite(swMat);
          swSprite.scale.set(1, 1, 1);
          swSprite.position.set(0, 1 + blastLevel * 4, 0);
          world.add(swSprite);
          doomShockwave = { sprite: swSprite, mat: swMat, tex: swTex, age: 0 };
        }

        // Expand shockwave
        if (doomShockwave) {
          doomShockwave.age += dt;
          const swT = Math.min(1, doomShockwave.age / 3);
          const swScale = 2 + swT * 80;
          doomShockwave.sprite.scale.set(swScale, swScale, 1);
          doomShockwave.mat.opacity = (1 - swT) * 0.6;
        }

        if (t >= 1) {
          doomState = 'blackout';
          doomAge = 0;
          console.log('[DOOM] Ritual complete — entering blackout');

          // Cleanup ritual visuals
          cleanupDoomRitual();

          // Remove all vessels
          for (const key in materiaVessels) {
            const v = materiaVessels[key];
            world.remove(v.group);
            v.baseMat.dispose(); v.vesselTex.dispose();
            v.ringMat.dispose(); v.ring2.material.dispose();
            v.miniOrbTex.dispose();
            v.miniOrbs.forEach(mo => mo.mat.dispose());
            if (v.shieldMat) { v.shieldMat.dispose(); v.shieldTex.dispose(); }
            if (v.lightnings) {
              v.lightnings.forEach(l => {
                v.group.remove(l.line); l.line.geometry.dispose(); l.line.material.dispose();
              });
            }
          }
          for (const key in materiaVessels) delete materiaVessels[key];
          vesselCount = 0;

          // Remove all beams
          for (const key in archetypBeams) removeBeam(key);

          // Remove all existing demons (will be replaced by captivity demons)
          for (const d of demons) {
            world.remove(d.group);
            d.orbMat.dispose(); d.auraMat.dispose(); d.orbTex.dispose();
            if (d.lightnings) {
              d.lightnings.forEach(l => { d.group.remove(l.line); l.line.geometry.dispose(); l.line.material.dispose(); });
            }
          }
          demons.length = 0;

          // Remove materia orbs
          for (const orb of materiaOrbs) {
            if (orb.group.parent) orb.group.parent.remove(orb.group);
            orb.orbMat.dispose(); orb.glowMat.dispose();
            orb.orbTex.dispose(); orb.wispTex.dispose();
            orb.wisps.forEach(w => w.mat.dispose());
          }
          materiaOrbs.length = 0;

          // Kill transfers
          for (const ta of transferAnimations) {
            world.remove(ta.sprite); ta.mat.dispose(); ta.tex.dispose();
          }
          transferAnimations.length = 0;

          archetypSpeedOverride = 0;
        }

      } else if (doomState === 'blackout') {
        // Phase 5: Complete darkness — 5 seconds
        sceneDarkness = 1.0;
        archetypSpeedOverride = 0;
        world.visible = false;
        coreGroup.visible = false;
        starField.visible = false;
        scene.background = new THREE.Color(0x000000);
        coreLight.intensity = 0;
        dirLight.intensity = 0;

        const t = Math.min(1, doomAge / DOOM_BLACKOUT_SEC);
        if (t >= 1) {
          doomState = 'message';
          doomAge = 0;

          // Create overlay
          const overlay = document.createElement('div');
          overlay.id = 'doom-overlay';
          overlay.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000000; z-index: 9999;
            display: flex; align-items: center; justify-content: center;
            flex-direction: column; padding: 30px;
          `;
          const msgEl = document.createElement('div');
          msgEl.id = 'doom-msg-text';
          msgEl.style.cssText = `
            font-family: 'Courier New', monospace;
            color: rgba(200, 170, 120, 0.85);
            font-size: 26px; letter-spacing: 6px;
            text-transform: uppercase; text-align: center;
            line-height: 2.2; max-width: 800px;
            opacity: 0;
            transition: opacity 0.1s linear;
          `;
          msgEl.textContent = 'Licht siegt. Nacht dient. Vertraue.';
          overlay.appendChild(msgEl);
          document.body.appendChild(overlay);
        }

      } else if (doomState === 'message') {
        // Phase 6: Show message 10 seconds, then transition to captivity
        sceneDarkness = 1.0;
        const t = Math.min(1, doomAge / DOOM_MESSAGE_SEC);

        // Fade in text during first 30%, hold, fade out during last 25%
        const msgText = document.getElementById('doom-msg-text');
        if (msgText) {
          if (t < 0.3) {
            msgText.style.opacity = String(t / 0.3);
          } else if (t > 0.75) {
            msgText.style.opacity = String(1 - ((t - 0.75) / 0.25));
          } else {
            msgText.style.opacity = '1';
          }
        }

        if (t >= 1) {
          doomState = 'captivity';
          doomAge = 0;
          console.log('[DOOM] Message done — showing captivity');

          // Remove text overlay
          const overlay = document.getElementById('doom-overlay');
          if (overlay) overlay.remove();

          // Make 3D world visible again but very dark
          world.visible = true;
          coreGroup.visible = true;
          starField.visible = true;

          // Spawn 12 captivity demons circling the chip
          const demonY = 1.0 + blastLevel * 4;
          for (let ci = 0; ci < 12; ci++) {
            const angle = (ci / 12) * Math.PI * 2;
            const radius = 5;
            const group = new THREE.Group();
            group.position.set(Math.cos(angle) * radius, demonY + Math.sin(ci * 1.3) * 0.5, Math.sin(angle) * radius);

            const orbTex = createOrbTexture(0.12, 0.08, 0.2);
            const orbMat = new THREE.SpriteMaterial({
              map: orbTex, transparent: true, opacity: 0,
              blending: THREE.NormalBlending, depthWrite: false,
            });
            const orbSprite = new THREE.Sprite(orbMat);
            orbSprite.scale.set(1.8, 1.8, 1);
            group.add(orbSprite);

            const auraMat = new THREE.SpriteMaterial({
              map: orbTex, transparent: true, opacity: 0,
              blending: THREE.AdditiveBlending, depthWrite: false,
              color: new THREE.Color(0.2, 0.05, 0.3),
            });
            const auraSprite = new THREE.Sprite(auraMat);
            auraSprite.scale.set(3.5, 3.5, 1);
            group.add(auraSprite);

            // Lightning
            const lns = [];
            const lMat = new THREE.LineBasicMaterial({ color: 0xcc99ff, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
            for (let l = 0; l < 3; l++) {
              const geo = new THREE.BufferGeometry();
              const posArr = new Float32Array(15);
              geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
              const line = new THREE.Line(geo, lMat.clone());
              group.add(line);
              lns.push({ line, posArr });
            }

            const dLight = new THREE.PointLight(0x664488, 0.5, 6);
            group.add(dLight);
            world.add(group);

            captivityDemons.push({
              group, orbMat, orbSprite, auraMat, auraSprite, orbTex, dLight,
              lightnings: lns,
              angle, radius,
              idx: ci,
            });
          }
        }

      } else if (doomState === 'captivity') {
        // Phase 7: Chip trapped by demons — dark scene, 5 seconds
        const t = Math.min(1, doomAge / DOOM_CAPTIVITY_SEC);
        const fadeIn = Math.min(1, doomAge * 0.5);
        sceneDarkness = 0.85;
        archetypSpeedOverride = 0;

        // Base Y position for this level
        const baseDemonY = 1.0 + blastLevel * 4;

        // Rotate captivity demons around chip
        for (const cd of captivityDemons) {
          cd.angle += 0.008;
          const bobY = baseDemonY + Math.sin(elapsed * 2 + cd.idx) * 0.4;
          cd.group.position.set(Math.cos(cd.angle) * cd.radius, bobY, Math.sin(cd.angle) * cd.radius);

          cd.orbMat.opacity = fadeIn * 0.8;
          cd.auraMat.opacity = fadeIn * 0.3;
          cd.dLight.intensity = fadeIn * 0.8;

          const pulse = 1 + Math.sin(elapsed * 6 + cd.idx * 0.5) * 0.15;
          cd.orbSprite.scale.set(1.8 * pulse, 1.8 * pulse, 1);
          cd.auraSprite.scale.set(3.5 * pulse, 3.5 * pulse, 1);

          if (cd.lightnings && Math.random() > 0.4) {
            cd.lightnings.forEach(l => {
              l.line.material.opacity = 0.3 + Math.random() * 0.5;
              l.line.material.color.setHSL(0.75 + Math.random() * 0.1, 0.8, 0.6 + Math.random() * 0.4);
              const pos = l.posArr;
              for (let v = 0; v < 5; v++) {
                const i3 = v * 3;
                pos[i3] = (Math.random() - 0.5) * 1.5;
                pos[i3 + 1] = (Math.random() - 0.5) * 1.5;
                pos[i3 + 2] = (Math.random() - 0.5) * 1.5;
              }
              l.line.geometry.attributes.position.needsUpdate = true;
            });
          }
        }

        // Dim chip glow — it's suffering
        coreLight.intensity = 0.05 + Math.sin(elapsed * 3) * 0.03;

        if (t >= 1) {
          doomState = 'archangels_enter';
          doomAge = 0;
          console.log('[DOOM] Captivity shown — archangels entering!');

          // Spawn 12 archangels from far away
          // Archangels scale in power with blast level
          const archScale = 1.0 + blastLevel * 0.15; // bigger at higher levels
          const archLightMul = 1.0 + blastLevel * 0.3;
          const archStartY = 8 + blastLevel * 4;
          for (let ai = 0; ai < 12; ai++) {
            const angle = (ai / 12) * Math.PI * 2;
            const spawnR = 50;
            const group = new THREE.Group();
            group.position.set(Math.cos(angle) * spawnR, archStartY + Math.random() * 5, Math.sin(angle) * spawnR);

            // Archangel color shifts with level — golden → brilliant white → prismatic
            let orbR = 1.0, orbG = 0.95, orbB = 0.7;
            let auraR2 = 1.0, auraG2 = 0.85, auraB2 = 0.5;
            let wingR = 1.0, wingG = 1.0, wingB = 0.9;
            let lightHex = 0xfff0c0;

            if (blastLevel <= 2) {
              // Warm golden
            } else if (blastLevel <= 4) {
              // Brilliant white-gold
              orbR = 1.0; orbG = 0.98; orbB = 0.85;
              auraR2 = 1.0; auraG2 = 0.95; auraB2 = 0.7;
              wingR = 1.0; wingG = 1.0; wingB = 0.95;
              lightHex = 0xfffff0;
            } else if (blastLevel <= 6) {
              // Cool platinum
              orbR = 0.9; orbG = 0.95; orbB = 1.0;
              auraR2 = 0.85; auraG2 = 0.9; auraB2 = 1.0;
              wingR = 0.95; wingG = 0.97; wingB = 1.0;
              lightHex = 0xe8f0ff;
            } else if (blastLevel <= 8) {
              // Celestial blue-white
              orbR = 0.85; orbG = 0.92; orbB = 1.0;
              auraR2 = 0.7; auraG2 = 0.85; auraB2 = 1.0;
              wingR = 0.9; wingG = 0.95; wingB = 1.0;
              lightHex = 0xd0e8ff;
            } else {
              // Prismatic radiance
              orbR = 1.0; orbG = 1.0; orbB = 1.0;
              auraR2 = 0.95; auraG2 = 0.9; auraB2 = 1.0;
              wingR = 1.0; wingG = 0.98; wingB = 1.0;
              lightHex = 0xffffff;
            }

            // Brilliant orb
            const orbTex = createOrbTexture(orbR, orbG, orbB);
            const orbMat = new THREE.SpriteMaterial({
              map: orbTex, transparent: true, opacity: 0,
              blending: THREE.AdditiveBlending, depthWrite: false,
            });
            const orbSprite = new THREE.Sprite(orbMat);
            orbSprite.scale.set(2.5 * archScale, 2.5 * archScale, 1);
            group.add(orbSprite);

            // Radiant aura
            const auraTex = createOrbTexture(auraR2, auraG2, auraB2);
            const auraMat = new THREE.SpriteMaterial({
              map: auraTex, transparent: true, opacity: 0,
              blending: THREE.AdditiveBlending, depthWrite: false,
            });
            const auraSprite = new THREE.Sprite(auraMat);
            auraSprite.scale.set(5 * archScale, 5 * archScale, 1);
            group.add(auraSprite);

            // Wing-like secondary flares
            const wingTex = createOrbTexture(wingR, wingG, wingB);
            const wingMat = new THREE.SpriteMaterial({
              map: wingTex, transparent: true, opacity: 0,
              blending: THREE.AdditiveBlending, depthWrite: false,
            });
            const wingSprite = new THREE.Sprite(wingMat);
            wingSprite.scale.set(3 * archScale, 6 * archScale, 1);
            group.add(wingSprite);

            const aLight = new THREE.PointLight(lightHex, 0, 12 * archScale);
            group.add(aLight);

            world.add(group);

            archangels.push({
              group, orbMat, orbSprite, auraMat, auraSprite, wingMat, wingSprite, orbTex, auraTex, wingTex, aLight,
              angle,
              spawnPos: group.position.clone(),
              targetDemon: captivityDemons[ai] || captivityDemons[ai % captivityDemons.length],
              idx: ai,
              phase: 'enter', // enter | battle | heal | leave
              archScale: archScale,
              archLightMul: archLightMul,
            });
          }
        }

      } else if (doomState === 'archangels_enter') {
        // Phase 8: 12 archangels fly in — 5 seconds
        const t = Math.min(1, doomAge / DOOM_ARCH_ENTER_SEC);
        const smooth = t * t * (3 - 2 * t);
        sceneDarkness = 0.85 - smooth * 0.15; // slightly brighter as they arrive

        // Archangels fly toward their target demons
        for (const a of archangels) {
          const td = a.targetDemon;
          const targetPos = td.group.position;
          // Stop at a distance of ~3 from the demon
          const stopR = 3.5;
          const dAngle = Math.atan2(targetPos.z, targetPos.x);
          const stopX = targetPos.x + Math.cos(dAngle + Math.PI) * stopR;
          const stopZ = targetPos.z + Math.sin(dAngle + Math.PI) * stopR;
          const stopY = targetPos.y + 1;

          a.group.position.x = a.spawnPos.x + (stopX - a.spawnPos.x) * smooth;
          a.group.position.y = a.spawnPos.y + (stopY - a.spawnPos.y) * smooth;
          a.group.position.z = a.spawnPos.z + (stopZ - a.spawnPos.z) * smooth;

          a.orbMat.opacity = smooth * 0.9;
          a.auraMat.opacity = smooth * 0.5;
          a.wingMat.opacity = smooth * 0.3;
          a.aLight.intensity = smooth * 2 * (a.archLightMul || 1);

          const pulse = 1 + Math.sin(elapsed * 5 + a.idx) * 0.1;
          const as = a.archScale || 1;
          a.orbSprite.scale.set(2.5 * as * pulse, 2.5 * as * pulse, 1);
        }

        // Captivity demons react — flicker nervously
        for (const cd of captivityDemons) {
          cd.angle += 0.006;
          cd.group.position.x = Math.cos(cd.angle) * cd.radius;
          cd.group.position.z = Math.sin(cd.angle) * cd.radius;
          const flicker = Math.random() > 0.8 ? 0.3 : 1.0;
          cd.orbMat.opacity = 0.8 * flicker;
          cd.auraMat.opacity = 0.3 * flicker;
        }

        if (t >= 1) {
          doomState = 'archangels_battle';
          doomAge = 0;
          console.log('[DOOM] Archangels in position — BATTLE!');
        }

      } else if (doomState === 'archangels_battle') {
        // Phase 9: Each archangel destroys a demon — 8 seconds
        const t = Math.min(1, doomAge / DOOM_ARCH_BATTLE_SEC);
        sceneDarkness = 0.7 - t * 0.2;

        // Stagger the battles — each demon destroyed at different time
        for (let ai = 0; ai < archangels.length; ai++) {
          const a = archangels[ai];
          const cd = a.targetDemon;
          if (!cd || !cd.group.parent) continue;

          // Each angel strikes at a staggered time
          const strikeTime = (ai / archangels.length) * 0.7; // spread over 70% of phase
          const strikeT = Math.max(0, (t - strikeTime) / 0.15); // each strike takes 15% of phase

          if (strikeT <= 0) {
            // Waiting — hover menacingly
            const hover = 1 + Math.sin(elapsed * 4 + ai) * 0.1;
            a.orbSprite.scale.set(2.5 * hover, 2.5 * hover, 1);
            a.aLight.intensity = 2;
          } else if (strikeT < 1) {
            // Charging toward demon
            const charge = Math.min(1, strikeT);
            const cSmooth = charge * charge * (3 - 2 * charge);
            a.group.position.lerpVectors(a.group.position, cd.group.position, cSmooth * 0.15);
            a.orbMat.opacity = 0.9 + cSmooth * 0.1;
            a.aLight.intensity = 2 + cSmooth * 6;

            // Demon flickers and shrinks
            cd.orbMat.opacity = (1 - cSmooth) * 0.8;
            cd.auraMat.opacity = (1 - cSmooth) * 0.3;
            const dScale = 1 - cSmooth * 0.7;
            cd.orbSprite.scale.set(1.8 * dScale, 1.8 * dScale, 1);
            cd.dLight.intensity = (1 - cSmooth) * 0.8;
          } else {
            // Demon destroyed — flash and remove
            if (cd.group.parent) {
              world.remove(cd.group);
              cd.orbMat.dispose(); cd.auraMat.dispose(); cd.orbTex.dispose();
              cd.lightnings.forEach(l => {
                cd.group.remove(l.line); l.line.geometry.dispose(); l.line.material.dispose();
              });
            }

            // Angel glows triumphantly
            a.orbMat.opacity = 0.9;
            a.aLight.intensity = 3 + Math.sin(elapsed * 6) * 1;
            const triumphPulse = 1 + Math.sin(elapsed * 4 + ai * 0.5) * 0.15;
            a.orbSprite.scale.set(2.8 * triumphPulse, 2.8 * triumphPulse, 1);
            a.auraSprite.scale.set(5.5 * triumphPulse, 5.5 * triumphPulse, 1);
          }
        }

        if (t >= 1) {
          // Clean up any remaining captivity demons
          for (const cd of captivityDemons) {
            if (cd.group.parent) {
              world.remove(cd.group);
              cd.orbMat.dispose(); cd.auraMat.dispose(); cd.orbTex.dispose();
              cd.lightnings.forEach(l => {
                cd.group.remove(l.line); l.line.geometry.dispose(); l.line.material.dispose();
              });
            }
          }
          captivityDemons = [];

          doomState = 'healing';
          doomAge = 0;
          console.log('[DOOM] All demons vanquished — healing the core!');
        }

      } else if (doomState === 'healing') {
        // Phase 10: Archangels circle the chip and heal everything — 6 seconds
        const t = Math.min(1, doomAge / DOOM_HEALING_SEC);
        const smooth = t * t * (3 - 2 * t);

        // Light returns
        sceneDarkness = 0.5 * (1 - smooth);

        // Archangels form a circle and orbit the chip, drawing inward
        const healRadius = 6 - smooth * 2;
        const healYBase = 1.5 + blastLevel * 4;
        for (let ai = 0; ai < archangels.length; ai++) {
          const a = archangels[ai];
          const hAngle = (ai / archangels.length) * Math.PI * 2 + elapsed * 0.5;
          const hY = healYBase + Math.sin(elapsed * 2 + ai * 0.5) * 0.3;

          // Smoothly transition to healing orbit
          const targetX = Math.cos(hAngle) * healRadius;
          const targetZ = Math.sin(hAngle) * healRadius;
          a.group.position.x += (targetX - a.group.position.x) * 0.05;
          a.group.position.z += (targetZ - a.group.position.z) * 0.05;
          a.group.position.y += (hY - a.group.position.y) * 0.05;

          // Radiant healing glow
          const healPulse = 0.8 + Math.sin(elapsed * 3 + ai * 0.5) * 0.2;
          a.orbMat.opacity = healPulse;
          a.auraMat.opacity = 0.4 + smooth * 0.3;
          a.wingMat.opacity = 0.2 + smooth * 0.3;
          a.aLight.intensity = 2 + smooth * 3;
          a.aLight.color.setRGB(1, 0.95, 0.7);

          // Angels grow slightly during healing
          const sc = 1 + smooth * 0.3;
          a.orbSprite.scale.set(2.5 * sc * healPulse, 2.5 * sc * healPulse, 1);
          a.auraSprite.scale.set(5 * sc, 5 * sc, 1);
          a.wingSprite.scale.set(3 * sc, 6 * sc, 1);
        }

        // Chip recovers — generator starts spinning again
        archetypSpeedOverride = smooth * 0.8;
        coreLight.intensity = 0.05 + smooth * 1.5;
        coreLight.color.setRGB(1, 0.92, 0.7);

        if (t >= 1) {
          doomState = 'archangels_leave';
          doomAge = 0;
          console.log('[DOOM] Healing complete — archangels departing');
        }

      } else if (doomState === 'archangels_leave') {
        // Phase 11: Archangels ascend and vanish — 5 seconds
        const t = Math.min(1, doomAge / DOOM_ARCH_LEAVE_SEC);
        const smooth = t * t * (3 - 2 * t);

        sceneDarkness = 0;

        for (let ai = 0; ai < archangels.length; ai++) {
          const a = archangels[ai];
          // Rise and fade
          a.group.position.y += 0.06 + smooth * 0.15;
          // Drift outward slightly
          const outAngle = Math.atan2(a.group.position.z, a.group.position.x);
          a.group.position.x += Math.cos(outAngle) * smooth * 0.04;
          a.group.position.z += Math.sin(outAngle) * smooth * 0.04;

          // Fade out
          a.orbMat.opacity = (1 - smooth) * 0.9;
          a.auraMat.opacity = (1 - smooth) * 0.5;
          a.wingMat.opacity = (1 - smooth) * 0.4;
          a.aLight.intensity = (1 - smooth) * 4;
        }

        // Generator fully restored
        archetypSpeedOverride = 0.8;

        if (t >= 1) {
          // Cleanup archangels
          for (const a of archangels) {
            world.remove(a.group);
            a.orbMat.dispose(); a.auraMat.dispose(); a.wingMat.dispose();
            a.orbTex.dispose(); a.auraTex.dispose(); a.wingTex.dispose();
          }
          archangels = [];

          // FULL RELOAD — losing resets everything
          console.log('[DOOM] Archangels departed — GAME OVER. Reloading...');
          setTimeout(() => { window.location.reload(); }, 1500);
          return;
        }
      }

      // Update doom particles (all phases)
      for (let i = doomRitualParticles.length - 1; i >= 0; i--) {
        const p = doomRitualParticles[i];
        // Move toward target with spiral
        const dx = p.tx - p.sprite.position.x;
        const dy = p.ty - p.sprite.position.y;
        const dz = p.tz - p.sprite.position.z;
        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

        if (dist > 0.3) {
          const s = p.speed;
          p.wobble += p.wobbleSpeed * dt;
          const perpX = -dz / (dist || 1);
          const perpZ = dx / (dist || 1);
          p.sprite.position.x += (dx / dist) * s + perpX * Math.sin(p.wobble) * p.wobbleAmp * 0.02;
          p.sprite.position.y += (dy / dist) * s;
          p.sprite.position.z += (dz / dist) * s + perpZ * Math.cos(p.wobble) * p.wobbleAmp * 0.02;
          p.mat.opacity = 0.5 + Math.sin(p.wobble) * 0.3;
        } else {
          p.life -= 0.05;
          p.mat.opacity = Math.max(0, p.life * 0.6);
        }

        if (p.life <= 0) {
          world.remove(p.sprite);
          p.mat.dispose(); p.tex.dispose();
          doomRitualParticles.splice(i, 1);
        }
      }
    }

    function updateArchetypEvent(dt, elapsed) {
      if (archetypState === 'idle') return;
      archetypAge += dt;

      if (archetypState === 'slowdown') {
        // Decelerate logo rotation
        const t = Math.min(1, archetypAge / ARCHETYP_SLOWDOWN_SEC);
        const smooth = t * t * (3 - 2 * t);
        archetypSpeedOverride = 0.8 * (1 - smooth);

        // Vessels start glowing brighter
        for (const key in materiaVessels) {
          const v = materiaVessels[key];
          v.baseMat.opacity = v.fadeIn * (0.5 + t * 0.5);
          v.vLight.intensity = v.fadeIn * (0.8 + t * 2);
        }

        if (t >= 1) {
          archetypState = 'charge';
          archetypAge = 0;
          // Activate all beams for the charge
          for (const key in materiaVessels) {
            const v = materiaVessels[key];
            if (v.count >= 1) {
              const beam = getOrCreateBeam(v);
              beam.active = true;
            }
          }
        }
      } else if (archetypState === 'charge') {
        // Energy flows from vessels to core — beams brighten, core glows
        const t = Math.min(1, archetypAge / ARCHETYP_CHARGE_SEC);
        const smooth = t * t * (3 - 2 * t);
        archetypSpeedOverride = 0; // fully stopped

        // Intensify beams
        for (const key in archetypBeams) {
          const b = archetypBeams[key];
          b.opacity = 0.5 + smooth * 0.5;
          b.mat.opacity = b.opacity;
          // Speed up pulse
          b.pulseT += 0.02 * (1 + smooth * 2);
          if (b.pulseT > 1) b.pulseT = 0;
          b.pulseSprite.position.lerpVectors(b.startPos, b.endPos, b.pulseT);
          b.pulseMat.opacity = b.opacity * Math.sin(b.pulseT * Math.PI);
        }

        // Core gets brighter
        archetypBlastIntensity = smooth * 0.5;

        // Vessels dim as they transfer energy
        for (const key in materiaVessels) {
          const v = materiaVessels[key];
          v.baseMat.opacity = 1 - smooth * 0.5;
          v.vLight.intensity = (1 - smooth * 0.3) * 2;
        }

        if (t >= 1) {
          archetypState = 'blast';
          archetypAge = 0;
          playSound('levelup');
        }
      } else if (archetypState === 'blast') {
        // MASSIVE flash + beam from core upward
        const t = Math.min(1, archetypAge / ARCHETYP_BLAST_SEC);

        // Launch beam on first frame
        if (!blastBeam && archetypAge < 0.1) {
          blastBeam = createBlastBeam();
        }

        if (t < 0.15) {
          // Ramp up to blinding
          const ramp = t / 0.15;
          archetypBlastIntensity = 0.5 + ramp * 4.5;
          archetypSpeedOverride = ramp * ramp * 3;
        } else if (t < 0.5) {
          // Hold bright
          const hold = (t - 0.15) / 0.35;
          archetypBlastIntensity = 5 * (1 - hold * 0.3);
          archetypSpeedOverride = 3 - hold * 0.5;
        } else {
          // Decay from peak
          const decay = (t - 0.5) / 0.5;
          const smooth = decay * decay;
          archetypBlastIntensity = 3.5 * (1 - smooth);
          archetypSpeedOverride = 2.5 * (1 - smooth * 0.5);
        }

        // Fade beams during blast
        for (const key in archetypBeams) {
          archetypBeams[key].mat.opacity = Math.max(0, 1 - t * 2);
          archetypBeams[key].pulseMat.opacity = 0;
        }

        if (t >= 1) {
          archetypState = 'recover';
          archetypAge = 0;

          // Consume 1 materia from each vessel
          for (const key in materiaVessels) {
            const v = materiaVessels[key];
            if (v.count > 0) {
              v.count--;
              // Remove last mini orb
              if (v.miniOrbs.length > 0) {
                const last = v.miniOrbs.pop();
                v.group.remove(last.sprite);
                last.mat.dispose();
              }
            }
            // Deactivate beams for vessels now below 3
            if (v.count < 3 && archetypBeams[key]) {
              archetypBeams[key].active = false;
            }
          }

          // PURGE ALL DEMONS AND CLEANSE CORRUPTED VESSELS
          for (let i = demons.length - 1; i >= 0; i--) {
            const d = demons[i];
            world.remove(d.group);
            d.orbMat.dispose(); d.auraMat.dispose(); d.orbTex.dispose();
            if (d.lightnings) {
              d.lightnings.forEach(l => {
                d.group.remove(l.line);
                l.line.geometry.dispose();
                l.line.material.dispose();
              });
            }
            demons.splice(i, 1);
          }

          // Cleanse all corrupted vessels
          for (const key in materiaVessels) {
            const v = materiaVessels[key];
            if (v.corrupted) {
              v.corrupted = false;
              v.demonCount = 0;

              // Remove lightning effects
              if (v.lightnings) {
                v.lightnings.forEach(l => {
                  v.group.remove(l.line);
                  l.line.geometry.dispose();
                  l.line.material.dispose();
                });
                v.lightnings = null;
              }

              // Restore original vessel visuals
              v.baseMat.color = new THREE.Color(1, 1, 1);
              v.ringMat.color.copy(v.color);
              v.ring2.material.color.copy(v.color);
              v.vLight.color.copy(v.color);
            }
          }

          console.log('[ARCHETYP] Blast complete — 1 materia consumed, all demons purged, vessels cleansed');

          // ── LEVEL UP ──
          blastLevel++;
          addScore(SCORE_LEVEL_UP * blastLevel, 'level');
          updateScoreHUD('level');
          const LEVEL_Y_STEP = 4; // each level adds 4 units height
          const newLayerY = LAYER_Y[LAYER_Y.length - 1] + LEVEL_Y_STEP * blastLevel;
          const prevLayerY = LAYER_Y[LAYER_Y.length - 1] + LEVEL_Y_STEP * (blastLevel - 1);

          // Chip rises to new level
          const newChipY = 0.1 + blastLevel * LEVEL_Y_STEP;
          // Animate chip rise (handled in recover phase)
          coreGroup._targetY = newChipY;

          // Generate new trace layer — MORE traces each level (8 base + 4 per level)
          const layerTraceY = newLayerY + 0.1;
          const traceCount = 8 + blastLevel * 4;
          for (let tr = 0; tr < traceCount; tr++) {
            const angle = (tr / traceCount) * Math.PI * 2 + (srand() - 0.5) * 0.8;
            const startR = CHIP_R + 1 + srand() * 10;
            const sx = Math.cos(angle) * startR;
            const sz = Math.sin(angle) * startR;
            const dir = pick(['x+', 'x-', 'z+', 'z-']);
            routeTrace(sx, layerTraceY, sz, dir, layerTraceY, randInt(3, 9));
          }

          // Add longer traces that extend further out
          for (let tr = 0; tr < 4 + blastLevel * 2; tr++) {
            const angle = srand() * Math.PI * 2;
            const startR = 15 + srand() * 30;
            const sx = Math.cos(angle) * startR;
            const sz = Math.sin(angle) * startR;
            const dir = pick(['x+', 'x-', 'z+', 'z-']);
            routeTrace(sx, layerTraceY, sz, dir, layerTraceY, randInt(4, 10));
          }

          // VERTICAL VIAS — connect new layer to previous layer
          const viaCount = 6 + blastLevel * 3;
          for (let vi = 0; vi < viaCount; vi++) {
            const vAngle = (vi / viaCount) * Math.PI * 2 + srand() * 0.5;
            const vR = 3 + srand() * 35;
            const vx = Math.cos(vAngle) * vR;
            const vz = Math.sin(vAngle) * vR;
            const fromY = blastLevel <= 1 ? (pick(LAYER_Y) + 0.1) : (prevLayerY + 0.1);
            const toY = layerTraceY;
            const viaPts = [
              new THREE.Vector3(vx, fromY, vz),
              new THREE.Vector3(vx, toY, vz)
            ];
            world.add(createFadingLine(viaPts, rand(0.15, 0.3), 0));
            allTraces.push(viaPts);
          }

          // Move vessels up too - set target for smooth animation
          for (const key in materiaVessels) {
            const v = materiaVessels[key];
            v._targetY = 1.5 + blastLevel * LEVEL_Y_STEP;
          }

          console.log(`[LEVEL UP] Blast level ${blastLevel} — chip at Y=${newChipY.toFixed(1)}, ${traceCount} traces + ${viaCount} vias, demons ${Math.max(3, DEMON_INTERVAL_MIN - blastLevel)}s faster`);

          // ACTIVATE BLAST SHIELD
          createGlobalShield();
        }
      } else if (archetypState === 'recover') {
        // Ease back to normal
        const t = Math.min(1, archetypAge / ARCHETYP_RECOVER_SEC);
        const smooth = t * t * (3 - 2 * t);
        archetypBlastIntensity = 0;
        archetypSpeedOverride = 1.5 * (1 - smooth) + 0.8 * smooth;

        // Butterweich: ultra-smooth exponential ease for chip rise
        if (coreGroup._targetY !== undefined) {
          const dy = coreGroup._targetY - coreGroup.position.y;
          coreGroup.position.y += dy * (1 - Math.pow(0.96, 1)); // smooth exponential
        }

        // Vessels return to normal — ultra-smooth rise to new level
        for (const key in materiaVessels) {
          const v = materiaVessels[key];
          v.baseMat.opacity = v.fadeIn * 0.5;
          v.vLight.intensity = v.fadeIn * 0.8;
          const vesselTargetY = v._targetY !== undefined ? v._targetY : (1.5 + blastLevel * 4);
          const vdy = vesselTargetY - v.group.position.y;
          v.group.position.y += vdy * (1 - Math.pow(0.92, 1));
        }

        // Cinematic camera sweep on level-up
        if (blastLevel > 0 && t < 0.8) {
          const camT = t / 0.8;
          const camSmooth = camT * camT * (3 - 2 * camT);
          // Tilt camera to show the new layer being built
          const levelCamX = -0.4 - camSmooth * 0.3 + Math.sin(camT * Math.PI) * 0.2;
          world.rotation.x += (levelCamX - world.rotation.x) * 0.02;
          // Slight zoom out to show the growing structure
          const levelZoom = 1.0 - camSmooth * 0.15 + Math.sin(camT * Math.PI) * 0.1;
          camera.zoom += (levelZoom - camera.zoom) * 0.02;
          camera.updateProjectionMatrix();
        }

        if (t >= 1) {
          archetypState = 'idle';
          archetypSpeedOverride = null;
          archetypBlastIntensity = 0;

          // CHECK LEVEL 10 VICTORY
          if (blastLevel >= 10) {
            triggerVictory();
          }
        }
      }
    }

    // ══════════════════════════════════════════════════════
    //  BLAST SHIELD SPHERE — protects chip + vessels
    // ══════════════════════════════════════════════════════
    const SHIELD_SPHERE_RADIUS = 15;
    const SHIELD_MAX_HP = 5;
    let globalShield = null; // { mesh, mat, glowSprite, glowMat, hp, age, fadingOut }

    function createGlobalShield() {
      // Remove existing shield if any
      removeGlobalShield();

      const geo = new THREE.SphereGeometry(SHIELD_SPHERE_RADIUS, 16, 10);
      const mat = new THREE.MeshBasicMaterial({
        color: 0xdfc090,
        transparent: true,
        opacity: 0,
        wireframe: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        side: THREE.DoubleSide,
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(0, 1 + blastLevel * 4, 0);
      world.add(mesh);

      // Inner soft glow sphere
      const glowGeo = new THREE.SphereGeometry(SHIELD_SPHERE_RADIUS - 0.3, 12, 8);
      const glowMat = new THREE.MeshBasicMaterial({
        color: 0xfff0c0,
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        side: THREE.BackSide,
      });
      const glowMesh = new THREE.Mesh(glowGeo, glowMat);
      glowMesh.position.set(0, 1 + blastLevel * 4, 0);
      world.add(glowMesh);

      globalShield = {
        mesh, mat, geo,
        glowMesh, glowMat, glowGeo,
        hp: SHIELD_MAX_HP,
        age: 0,
        fadingOut: false,
        fadeOutAge: 0,
        hitFlash: 0, // flash timer on hit
      };

      console.log(`[SHIELD] Blast shield activated — ${SHIELD_MAX_HP} charges`);
    }

    function removeGlobalShield() {
      if (!globalShield) return;
      world.remove(globalShield.mesh);
      world.remove(globalShield.glowMesh);
      globalShield.mat.dispose();
      globalShield.geo.dispose();
      globalShield.glowMat.dispose();
      globalShield.glowGeo.dispose();
      globalShield = null;
    }

    function hitGlobalShield() {
      if (!globalShield || globalShield.fadingOut) return false;
      globalShield.hp--;
      globalShield.hitFlash = 1.0; // trigger flash
      addScore(SCORE_SHIELD_BLOCK, 'score');
      updateScoreHUD();
      console.log(`[SHIELD] Hit! ${globalShield.hp} charges remaining`);

      if (globalShield.hp <= 0) {
        globalShield.fadingOut = true;
        globalShield.fadeOutAge = 0;
        console.log('[SHIELD] Shield depleted — fading out');
      }
      return true;
    }

    function updateGlobalShield(dt, elapsed) {
      if (!globalShield) return;
      const s = globalShield;
      s.age += dt;

      if (s.fadingOut) {
        // Fade out over 2 seconds
        s.fadeOutAge += dt;
        const fadeT = Math.min(1, s.fadeOutAge / 2);
        s.mat.opacity = Math.max(0, (1 - fadeT) * 0.15);
        s.glowMat.opacity = Math.max(0, (1 - fadeT) * 0.06);

        if (fadeT >= 1) {
          removeGlobalShield();
        }
        return;
      }

      // Fade in during first second
      const fadeIn = Math.min(1, s.age / 1.0);

      // Base pulsing opacity — scales with remaining HP
      const hpRatio = s.hp / SHIELD_MAX_HP;
      const basePulse = 0.03 + Math.sin(elapsed * 2) * 0.015;
      const wireOpacity = fadeIn * (basePulse + hpRatio * 0.03);
      const glowOpacity = fadeIn * (0.008 + hpRatio * 0.015 + Math.sin(elapsed * 3) * 0.005);

      // Hit flash effect
      let flashAdd = 0;
      if (s.hitFlash > 0) {
        s.hitFlash = Math.max(0, s.hitFlash - dt * 3);
        flashAdd = s.hitFlash * 0.1;
        // Flash color toward white on hit
        const flashCol = s.hitFlash;
        s.mat.color.setRGB(0.87 + flashCol * 0.13, 0.75 + flashCol * 0.25, 0.56 + flashCol * 0.44);
        s.glowMat.color.setRGB(1, 0.94 + flashCol * 0.06, 0.75 + flashCol * 0.25);
      } else {
        // Color shifts slightly based on HP
        s.mat.color.setHSL(0.1, 0.3 + hpRatio * 0.2, 0.6 + hpRatio * 0.15);
        s.glowMat.color.setHSL(0.1, 0.2, 0.8 + hpRatio * 0.1);
      }

      s.mat.opacity = wireOpacity + flashAdd;
      s.glowMat.opacity = glowOpacity + flashAdd * 0.3;

      // Gentle rotation
      s.mesh.rotation.y = elapsed * 0.05;
      s.mesh.rotation.x = Math.sin(elapsed * 0.03) * 0.1;
      s.glowMesh.rotation.y = -elapsed * 0.03;
    }

    // ══════════════════════════════════════════════════════
    //  DEMONS & ANGELS — gray materia threat system
    // ══════════════════════════════════════════════════════
    const demons = [];
    const DEMON_INTERVAL_MIN = 15;
    const DEMON_INTERVAL_MAX = 40;
    let nextDemonTime = 80; // first demon after 80s
    const BOARD_EDGE = 30;
    let totalInfections = 0; // Tracks total infections for spawn escalation
    let blastLevel = 0; // Increments with each blast — chip rises, demons spawn faster

    // ── SCORING SYSTEM ──
    let gameScore = 0;
    let materiaCaught = 0;
    let demonsKilled = 0;
    let vesselsCleansed = 0;

    const SCORE_CATCH = 50;
    const SCORE_DEMON_KILL = 150;
    const SCORE_CLEANSE = 200;
    const SCORE_LEVEL_UP = 500;
    const SCORE_SHIELD_BLOCK = 75;

    function addScore(points, type) {
      gameScore += points;
      updateScoreHUD(type);
    }

    function updateScoreHUD(flashType) {
      const hudScore = document.getElementById('hud-score');
      const hudLevel = document.getElementById('hud-level');
      const hudCaught = document.getElementById('hud-caught');
      const hudDemonsKilled = document.getElementById('hud-demons-killed');
      const hudCleansed = document.getElementById('hud-cleansed');
      const hudShieldBar = document.getElementById('hud-shield-bar');
      const hudVesselBar = document.getElementById('hud-vessel-bar');

      if (hudScore) hudScore.textContent = gameScore.toLocaleString();
      if (hudLevel) hudLevel.textContent = blastLevel;
      if (hudCaught) hudCaught.textContent = materiaCaught;
      if (hudDemonsKilled) hudDemonsKilled.textContent = demonsKilled;
      if (hudCleansed) hudCleansed.textContent = vesselsCleansed;

      // Shield bar
      if (hudShieldBar) {
        const shieldPct = globalShield ? (globalShield.hp / SHIELD_MAX_HP * 100) : 0;
        hudShieldBar.style.width = shieldPct + '%';
        hudShieldBar.style.background = shieldPct > 40 ? 'rgba(240, 210, 160, 0.6)' : 'rgba(255, 120, 80, 0.7)';
      }

      // Vessel completion bar
      if (hudVesselBar) {
        const vessels = Object.values(materiaVessels);
        const totalNeeded = 12 * 3; // 12 vessels, 3 each
        const totalFilled = vessels.reduce((sum, v) => sum + Math.min(3, v.count), 0);
        const healthyFilled = vessels.filter(v => !v.corrupted).reduce((sum, v) => sum + Math.min(3, v.count), 0);
        const pct = totalNeeded > 0 ? (healthyFilled / totalNeeded * 100) : 0;
        hudVesselBar.style.width = pct + '%';
      }

      // Flash effect on changed value
      if (flashType) {
        let targetEl;
        if (flashType === 'score') targetEl = hudScore;
        else if (flashType === 'catch') targetEl = hudCaught;
        else if (flashType === 'demon') targetEl = hudDemonsKilled;
        else if (flashType === 'cleanse') targetEl = hudCleansed;
        else if (flashType === 'level') targetEl = hudLevel;
        if (targetEl) {
          targetEl.classList.add('flash');
          setTimeout(() => targetEl.classList.remove('flash'), 400);
        }
      }
    }

    // Show score HUD when game starts
    function hideScoreHUD() {
      const hud = document.getElementById('score-hud');
      hud.classList.remove('visible');
      hud.style.visibility = 'hidden';
      hud.style.display = 'none';
    }
    function showScoreHUD() {
      const hud = document.getElementById('score-hud');
      hud.style.display = 'flex';
      hud.style.visibility = 'visible';
      hud.classList.add('visible');
    }

    function createDemonOrb() {
      const group = new THREE.Group();

      // Spawn at board edge, random Y across all layers
      const side = Math.floor(Math.random() * 4);
      let sx, sz;
      if (side === 0) { sx = -BOARD_EDGE + Math.random() * BOARD_EDGE * 2; sz = -BOARD_EDGE; }
      else if (side === 1) { sx = -BOARD_EDGE + Math.random() * BOARD_EDGE * 2; sz = BOARD_EDGE; }
      else if (side === 2) { sx = -BOARD_EDGE; sz = -BOARD_EDGE + Math.random() * BOARD_EDGE * 2; }
      else { sx = BOARD_EDGE; sz = -BOARD_EDGE + Math.random() * BOARD_EDGE * 2; }

      // Random spawn height — spans all existing layers plus some extra
      const minY = -5;
      const maxY = Math.max(5, blastLevel * 4 + 6);
      const sy = minY + Math.random() * (maxY - minY);
      group.position.set(sx, sy, sz);

      // ── DYNAMIC DEMON VISUALS BASED ON BLAST LEVEL ──
      // Level 0-1: Dark purple/black (original)
      // Level 2-3: Deeper crimson with red tones  
      // Level 4-5: Sickly green-purple
      // Level 6-7: Electric blue-violet
      // Level 8-9: Burning ember orange-black
      // Level 10: Pure void black with white corona

      let demonR, demonG, demonB;
      let auraR, auraG, auraB;
      let lightningColor, lightColor;
      let orbScale = 1.4;
      let auraScale = 3.0;
      let lightningCount = 3;
      let demonSpeed = 0.03 + Math.random() * 0.02;

      if (blastLevel <= 1) {
        // Original: deep purple
        demonR = 0.12; demonG = 0.08; demonB = 0.2;
        auraR = 0.15; auraG = 0.05; auraB = 0.25;
        lightningColor = 0xcc99ff; lightColor = 0x666680;
      } else if (blastLevel <= 3) {
        // Crimson demons
        demonR = 0.25; demonG = 0.04; demonB = 0.08;
        auraR = 0.3; auraG = 0.02; auraB = 0.1;
        lightningColor = 0xff4466; lightColor = 0x884444;
        orbScale = 1.5; auraScale = 3.2;
        lightningCount = 4;
        demonSpeed = 0.035 + Math.random() * 0.025;
      } else if (blastLevel <= 5) {
        // Toxic green-purple
        demonR = 0.08; demonG = 0.2; demonB = 0.12;
        auraR = 0.1; auraG = 0.25; auraB = 0.15;
        lightningColor = 0x44ff88; lightColor = 0x448866;
        orbScale = 1.6; auraScale = 3.5;
        lightningCount = 4;
        demonSpeed = 0.04 + Math.random() * 0.025;
      } else if (blastLevel <= 7) {
        // Electric blue-violet
        demonR = 0.06; demonG = 0.1; demonB = 0.35;
        auraR = 0.08; auraG = 0.15; auraB = 0.4;
        lightningColor = 0x6688ff; lightColor = 0x4466aa;
        orbScale = 1.7; auraScale = 3.8;
        lightningCount = 5;
        demonSpeed = 0.045 + Math.random() * 0.03;
      } else if (blastLevel <= 9) {
        // Burning ember
        demonR = 0.3; demonG = 0.12; demonB = 0.02;
        auraR = 0.35; auraG = 0.1; auraB = 0.03;
        lightningColor = 0xff8822; lightColor = 0xaa6622;
        orbScale = 1.8; auraScale = 4.0;
        lightningCount = 6;
        demonSpeed = 0.05 + Math.random() * 0.035;
      } else {
        // Void black with white corona
        demonR = 0.02; demonG = 0.02; demonB = 0.05;
        auraR = 0.8; auraG = 0.7; auraB = 0.9;
        lightningColor = 0xffffff; lightColor = 0xaaaacc;
        orbScale = 2.0; auraScale = 4.5;
        lightningCount = 7;
        demonSpeed = 0.055 + Math.random() * 0.04;
      }

      // Dark shadow core
      const orbTex = createOrbTexture(demonR, demonG, demonB);
      const orbMat = new THREE.SpriteMaterial({
        map: orbTex, transparent: true, opacity: 0,
        blending: THREE.NormalBlending, depthWrite: false,
      });
      const orbSprite = new THREE.Sprite(orbMat);
      orbSprite.scale.set(orbScale, orbScale, 1);
      group.add(orbSprite);

      // Dark aura
      const auraMat = new THREE.SpriteMaterial({
        map: orbTex, transparent: true, opacity: 0,
        blending: THREE.AdditiveBlending, depthWrite: false,
        color: new THREE.Color(auraR, auraG, auraB),
      });
      const auraSprite = new THREE.Sprite(auraMat);
      auraSprite.scale.set(auraScale, auraScale, 1);
      group.add(auraSprite);

      // Lightning arcs
      const lightnings = [];
      const lightningMat = new THREE.LineBasicMaterial({
        color: lightningColor, transparent: true, opacity: 0, blending: THREE.AdditiveBlending
      });

      for (let l = 0; l < lightningCount; l++) {
        const geo = new THREE.BufferGeometry();
        const posArr = new Float32Array(15); // 5 points
        geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
        const line = new THREE.Line(geo, lightningMat.clone());
        group.add(line);
        lightnings.push({ line, posArr });
      }

      const dLight = new THREE.PointLight(lightColor, 0, 4);
      group.add(dLight);

      world.add(group);

      // Pick a random NON-CORRUPTED vessel as target
      const vesselKeys = Object.keys(materiaVessels);
      const healthyVessels = vesselKeys.filter(key => !materiaVessels[key].corrupted);
      const targetKey = healthyVessels.length > 0 ? healthyVessels[Math.floor(Math.random() * healthyVessels.length)] : null;
      const targetVessel = targetKey ? materiaVessels[targetKey] : null;

      const demon = {
        group, orbSprite, orbMat, orbTex, auraSprite, auraMat, dLight, lightnings,
        age: 0,
        targetVessel,
        targetPos: targetVessel ? new THREE.Vector3(targetVessel.px, 1.5 + blastLevel * 4, targetVessel.pz) : new THREE.Vector3(0, 1.5 + blastLevel * 4, 0),
        speed: demonSpeed,
        // Curved path params
        wobbleFreqX: 1 + Math.random() * 2,
        wobbleFreqZ: 0.8 + Math.random() * 1.5,
        wobbleAmpX: 0.5 + Math.random() * 1.5,
        wobbleAmpZ: 0.5 + Math.random() * 1.5,
        phase: 'approach', // approach | corrupt
        converted: false, // true = became angel
      };

      demons.push(demon);
    }

    function convertToAngel(demon) {
      demon.converted = true;
      demon.phase = 'angel';
      demon.age = 0;
      demonsKilled++;
      addScore(SCORE_DEMON_KILL, 'demon');
      playSound('demon');

      // Flash white
      demon.orbMat.color = new THREE.Color(1, 1, 1);
      demon.orbMat.blending = THREE.AdditiveBlending;
      demon.auraMat.color = new THREE.Color(0.9, 0.9, 1);
      demon.dLight.color.setRGB(1, 1, 1);
      // Remove lightning on conversion
      if (demon.lightnings) {
        demon.lightnings.forEach(l => {
          demon.group.remove(l.line);
          l.line.geometry.dispose();
          l.line.material.dispose();
        });
        demon.lightnings = null;
      }

      // Find an unshielded vessel to protect
      const unshielded = Object.values(materiaVessels).filter(v => !v.shielded && !v.corrupted);
      if (unshielded.length > 0) {
        const target = unshielded[Math.floor(Math.random() * unshielded.length)];
        demon.targetVessel = target;
        demon.targetPos = new THREE.Vector3(target.px, 1.5, target.pz);
      }
    }

    function applyShield(vessel) {
      vessel.shielded = true;
      // Add shield visual
      const shieldTex = createOrbTexture(0.9, 0.9, 1);
      const shieldMat = new THREE.SpriteMaterial({
        map: shieldTex, transparent: true, opacity: 0.3,
        blending: THREE.AdditiveBlending, depthWrite: false,
      });
      const shieldSprite = new THREE.Sprite(shieldMat);
      shieldSprite.scale.set(3.5, 3.5, 1);
      vessel.group.add(shieldSprite);
      vessel.shieldSprite = shieldSprite;
      vessel.shieldMat = shieldMat;
      vessel.shieldTex = shieldTex;
    }

    function corruptVessel(vessel) {
      if (vessel.shielded) {
        // Shield absorbs the hit
        vessel.shielded = false;
        if (vessel.shieldSprite) {
          vessel.group.remove(vessel.shieldSprite);
          vessel.shieldMat.dispose(); vessel.shieldTex.dispose();
          vessel.shieldSprite = null;
        }
        return;
      }

      // Only corrupt once
      if (vessel.corrupted) return;

      vessel.corrupted = true;
      vessel.demonCount = 1;
      playSound('error');

      // SCORE PENALTY — lose points for corruption, minimum 0
      const penalty = 300 + blastLevel * 50;
      gameScore = Math.max(0, gameScore - penalty);
      updateScoreHUD('score');

      // DESTROY ALL MATERIA
      for (const mo of vessel.miniOrbs) {
        vessel.group.remove(mo.sprite);
        mo.mat.dispose();
      }
      vessel.miniOrbs = [];
      vessel.count = 0;

      // DISCONNECT BEAM
      if (archetypBeams[vessel.key]) {
        archetypBeams[vessel.key].active = false;
      }

      // ADD LIGHTNING EFFECTS (like demons)
      const lightningCount = 3;
      const lightnings = [];
      const lightningMat = new THREE.LineBasicMaterial({
        color: 0xcc99ff, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending
      });

      for (let l = 0; l < lightningCount; l++) {
        const geo = new THREE.BufferGeometry();
        const posArr = new Float32Array(15); // 5 points
        geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
        const line = new THREE.Line(geo, lightningMat.clone());
        vessel.group.add(line);
        lightnings.push({ line, posArr });
      }
      vessel.lightnings = lightnings;

      // Change color to BRIGHT aggressive purple/magenta (highly visible)
      vessel.baseMat.color = new THREE.Color(0.9, 0.2, 0.6); // Bright magenta
      vessel.ringMat.color.setRGB(1.0, 0.3, 0.7); // Vivid pink
      vessel.ring2.material.color.setRGB(0.8, 0.2, 0.6); // Deep magenta
      vessel.vLight.color.setRGB(1.0, 0.2, 0.7); // Intense pink light
      vessel.vLight.intensity = 2.5; // Much brighter

      console.log(`[CORRUPTION] Vessel ${vessel.key} infected - all materia destroyed`);
    }

    function updateDemons(dt, elapsed) {
      for (let i = demons.length - 1; i >= 0; i--) {
        const d = demons[i];
        d.age += dt;

        if (d.phase === 'approach') {
          // Fade in
          const fadeIn = Math.min(1, d.age * 0.5);
          d.orbMat.opacity = fadeIn * 0.8;
          d.auraMat.opacity = fadeIn * 0.3;
          d.dLight.intensity = fadeIn * 1;

          // If no target or target already corrupted, try to find a new one
          if (!d.targetVessel || d.targetVessel.corrupted) {
            const vesselKeys = Object.keys(materiaVessels);
            const healthyVessels = vesselKeys.filter(key => !materiaVessels[key].corrupted);
            if (healthyVessels.length > 0) {
              const newKey = healthyVessels[Math.floor(Math.random() * healthyVessels.length)];
              d.targetVessel = materiaVessels[newKey];
              d.targetPos = new THREE.Vector3(d.targetVessel.px, 1.5 + blastLevel * 4, d.targetVessel.pz);
            } else {
              // No healthy vessel exists — orbit and wait
              d.targetVessel = null;
              const orbitR = 18 + Math.sin(d.age * 0.3) * 3;
              const orbitAngle = d.age * 0.15 + d.wobbleFreqX;
              const wantX = Math.cos(orbitAngle) * orbitR;
              const wantZ = Math.sin(orbitAngle) * orbitR;
              d.group.position.x += (wantX - d.group.position.x) * 0.01;
              d.group.position.z += (wantZ - d.group.position.z) * 0.01;
              const orbitTargetY = 1.5 + blastLevel * 4;
              d.group.position.y += (orbitTargetY - d.group.position.y) * 0.01 + Math.sin(d.age * 0.8) * 0.03;

              // Pulse effect while waiting
              const pulse = 1 + Math.sin(d.age * 6) * 0.2;
              d.orbSprite.scale.set(1.4 * pulse, 1.4 * pulse, 1);
              d.auraSprite.scale.set(3 * pulse, 3 * pulse, 1);

              // Update lightning arcs while waiting
              if (d.lightnings && Math.random() > 0.4) {
                d.lightnings.forEach(l => {
                  const pos = l.posArr;
                  l.line.material.opacity = (0.3 + Math.random() * 0.7) * fadeIn;
                  l.line.material.color.setHSL(0.75 + Math.random() * 0.1, 0.8, 0.6 + Math.random() * 0.4);
                  for (let v = 0; v < 5; v++) {
                    const i3 = v * 3;
                    pos[i3] = (Math.random() - 0.5) * 1.1;
                    pos[i3 + 1] = (Math.random() - 0.5) * 1.1;
                    pos[i3 + 2] = (Math.random() - 0.5) * 1.1;
                  }
                  l.line.geometry.attributes.position.needsUpdate = true;
                });
              }
              continue; // skip normal approach logic
            }
          }

          // Move toward target with curved path
          const dx = d.targetPos.x - d.group.position.x;
          const dz = d.targetPos.z - d.group.position.z;
          const dist = Math.sqrt(dx * dx + dz * dz);

          // CHECK GLOBAL SHIELD — distance from world center
          if (globalShield && !globalShield.fadingOut) {
            const distFromCenter = Math.sqrt(
              d.group.position.x * d.group.position.x +
              d.group.position.z * d.group.position.z
            );
            if (distFromCenter <= SHIELD_SPHERE_RADIUS + 0.5) {
              // Demon hits the shield — destroy demon, damage shield
              hitGlobalShield();
              world.remove(d.group);
              d.orbMat.dispose(); d.auraMat.dispose(); d.orbTex.dispose();
              if (d.lightnings) {
                d.lightnings.forEach(l => {
                  d.group.remove(l.line); l.line.geometry.dispose(); l.line.material.dispose();
                });
              }
              demons.splice(i, 1);
              continue;
            }
          }

          if (dist > 0.5) {
            const dirX = dx / dist;
            const dirZ = dz / dist;
            // Perpendicular wobble
            const wobX = Math.sin(d.age * d.wobbleFreqX) * d.wobbleAmpX * (dist / BOARD_EDGE);
            const wobZ = Math.cos(d.age * d.wobbleFreqZ) * d.wobbleAmpZ * (dist / BOARD_EDGE);
            d.group.position.x += dirX * d.speed + (-dirZ) * wobX * 0.02;
            d.group.position.z += dirZ * d.speed + dirX * wobZ * 0.02;
            // Smoothly move Y toward target with wobble
            const targetY = d.targetPos.y;
            d.group.position.y += (targetY - d.group.position.y) * 0.02 + Math.sin(d.age * 1.5) * 0.02;
          } else {
            // Reached vessel — corrupt it
            if (d.targetVessel && !d.targetVessel.corrupted) {
              corruptVessel(d.targetVessel);

              // INCREMENT INFECTION COUNTER (affects next spawn wave)
              totalInfections++;
              console.log(`[DEMON] Vessel infected - total infections: ${totalInfections}, next spawn will have ${1 + totalInfections} demons`);
            }
            // Remove demon
            world.remove(d.group);
            d.orbMat.dispose(); d.auraMat.dispose(); d.orbTex.dispose();
            if (d.lightnings) {
              d.lightnings.forEach(l => {
                d.group.remove(l.line);
                l.line.geometry.dispose();
                l.line.material.dispose();
              });
            }
            demons.splice(i, 1);
            continue;
          }

          // Pulse effect
          const flicker = Math.random() > 0.9 ? 1.4 : 1.0;
          const pulse = (1 + Math.sin(d.age * 8) * 0.15) * flicker;
          d.orbSprite.scale.set(1.4 * pulse, 1.4 * pulse, 1);
          d.auraSprite.scale.set(3 * pulse, 3 * pulse, 1);

          // Update lightning arcs
          if (d.lightnings && Math.random() > 0.4) {
            d.lightnings.forEach(l => {
              const pos = l.posArr;
              l.line.material.opacity = (0.3 + Math.random() * 0.7) * fadeIn;
              l.line.material.color.setHSL(0.75 + Math.random() * 0.1, 0.8, 0.6 + Math.random() * 0.4);
              for (let v = 0; v < 5; v++) {
                const i3 = v * 3;
                pos[i3] = (Math.random() - 0.5) * 1.1;
                pos[i3 + 1] = (Math.random() - 0.5) * 1.1;
                pos[i3 + 2] = (Math.random() - 0.5) * 1.1;
              }
              l.line.geometry.attributes.position.needsUpdate = true;
            });
          }
        } else if (d.phase === 'angel') {
          // Move toward assigned vessel
          const fadeIn = Math.min(1, d.age * 0.8);
          d.orbMat.opacity = fadeIn * 0.9;
          d.auraMat.opacity = fadeIn * 0.4;
          d.dLight.intensity = fadeIn * 1.5;

          const dx = d.targetPos.x - d.group.position.x;
          const dz = d.targetPos.z - d.group.position.z;
          const dist = Math.sqrt(dx * dx + dz * dz);

          if (dist > 0.5) {
            d.group.position.x += (dx / dist) * 0.08;
            d.group.position.z += (dz / dist) * 0.08;
            d.group.position.y = (1.5 + blastLevel * 4) + Math.sin(d.age * 2) * 0.2;
          } else {
            // Arrived — apply shield
            if (d.targetVessel && !d.targetVessel.shielded) {
              applyShield(d.targetVessel);
            }
            world.remove(d.group);
            d.orbMat.dispose(); d.auraMat.dispose(); d.orbTex.dispose();
            demons.splice(i, 1);
            continue;
          }

          // White glow pulse
          const pulse = 1 + Math.sin(d.age * 5) * 0.1;
          d.orbSprite.scale.set(1.8 * pulse, 1.8 * pulse, 1);
          d.auraSprite.scale.set(3.5 * pulse, 3.5 * pulse, 1);
        }
      }
    }

    // ══════════════════════════════════════════════════════
    //  VESSEL TRANSFER — click vessel to decouple, click target to transfer
    // ══════════════════════════════════════════════════════
    let selectedVessel = null; // vessel being transferred from
    let transferAnimations = [];

    function startVesselTransfer(fromVessel, toVessel) {
      if (fromVessel === toVessel) { selectedVessel = null; return; }
      if (fromVessel.count < 3) { selectedVessel = null; return; }

      // If target is corrupted, need 2 materia to cleanse
      if (toVessel.corrupted) {
        if (fromVessel.count < 2) { selectedVessel = null; return; }

        // Remove 2 from source
        for (let r = 0; r < 2; r++) {
          fromVessel.count--;
          if (fromVessel.miniOrbs.length > 0) {
            const last = fromVessel.miniOrbs.pop();
            fromVessel.group.remove(last.sprite);
            last.mat.dispose();
          }
        }

        // CLEANSE THE VESSEL
        toVessel.corrupted = false;
        toVessel.demonCount = 0;

        // Remove lightning effects
        if (toVessel.lightnings) {
          toVessel.lightnings.forEach(l => {
            toVessel.group.remove(l.line);
            l.line.geometry.dispose();
            l.line.material.dispose();
          });
          toVessel.lightnings = null;
        }

        // Restore original vessel visuals
        toVessel.baseMat.color = new THREE.Color(1, 1, 1);
        toVessel.ringMat.color.copy(toVessel.color);
        toVessel.ring2.material.color.copy(toVessel.color);
        toVessel.vLight.color.copy(toVessel.color);

        // Animate cleansing flash
        createTransferAnim(fromVessel, toVessel, 'cleanse');
        vesselsCleansed++;
        addScore(SCORE_CLEANSE, 'cleanse');
        playSound('cleanse');
      } else {
        // Normal transfer: move 1 materia
        fromVessel.count--;
        if (fromVessel.miniOrbs.length > 0) {
          const last = fromVessel.miniOrbs.pop();
          fromVessel.group.remove(last.sprite);
          last.mat.dispose();
        }
        createTransferAnim(fromVessel, toVessel, 'transfer');
        playSound('click');
      }

      selectedVessel = null;
    }

    function createTransferAnim(from, to, type) {
      const tex = createOrbTexture(from.color.r, from.color.g, from.color.b);
      const mat = new THREE.SpriteMaterial({
        map: tex, transparent: true, opacity: 0.9,
        blending: THREE.AdditiveBlending, depthWrite: false,
      });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(1, 1, 1);
      
      // Account for blast level
      const vesselY = 1.5 + blastLevel * 4;
      sprite.position.set(from.px, vesselY, from.pz);
      world.add(sprite);

      transferAnimations.push({
        sprite, mat, tex,
        startPos: new THREE.Vector3(from.px, vesselY, from.pz),
        endPos: new THREE.Vector3(to.px, vesselY, to.pz),
        toVessel: to, type, age: 0, duration: 1.2,
      });
    }

    function updateTransferAnimations() {
      const vesselY = 1.5 + blastLevel * 4;
      for (let i = transferAnimations.length - 1; i >= 0; i--) {
        const ta = transferAnimations[i];
        ta.age += 1 / 60;
        const t = Math.min(1, ta.age / ta.duration);
        const smooth = t * t * (3 - 2 * t);

        // Arc path
        const mid = ta.startPos.clone().lerp(ta.endPos, 0.5);
        mid.y = vesselY + 3;
        const inv = 1 - smooth;
        ta.sprite.position.set(
          inv * inv * ta.startPos.x + 2 * inv * smooth * mid.x + smooth * smooth * ta.endPos.x,
          inv * inv * ta.startPos.y + 2 * inv * smooth * mid.y + smooth * smooth * ta.endPos.y,
          inv * inv * ta.startPos.z + 2 * inv * smooth * mid.z + smooth * smooth * ta.endPos.z
        );
        ta.mat.opacity = 0.9 * (1 - smooth * smooth);

        if (t >= 1) {
          world.remove(ta.sprite);
          ta.mat.dispose(); ta.tex.dispose();
          if (ta.type === 'transfer') {
            addMiniOrbToVessel(ta.toVessel);
          }
          transferAnimations.splice(i, 1);
        }
      }
    }

    // ══════════════════════════════════════════════════════
    //  GRADIENT LINE SHADER — fades with distance from center
    // ══════════════════════════════════════════════════════
    const fadeVertexShader = `
  attribute float alpha;
  varying float vAlpha;
  void main() {
    vAlpha = alpha;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;
    const fadeFragmentShader = `
  uniform vec3 color;
  varying float vAlpha;
  void main() {
    gl_FragColor = vec4(color, vAlpha);
  }
`;

    // Create a fading line from an array of points
    function createFadingLine(points, baseOpacity, layerY) {
      const positions = [];
      const alphas = [];

      for (let i = 0; i < points.length; i++) {
        const p = points[i];
        positions.push(p.x, p.y, p.z);
        // Distance from world center (XZ plane)
        const dist = Math.sqrt(p.x * p.x + p.z * p.z);
        // Smooth fade: full opacity near center, zero at FADE_RADIUS
        const fade = Math.max(0, 1 - (dist / FADE_RADIUS));
        // Smoothstep for nicer curve
        const smooth = fade * fade * (3 - 2 * fade);
        alphas.push(baseOpacity * smooth);
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geo.setAttribute('alpha', new THREE.Float32BufferAttribute(alphas, 1));

      const mat = new THREE.ShaderMaterial({
        uniforms: { color: { value: new THREE.Color(AMBER_LIGHT) } },
        vertexShader: fadeVertexShader,
        fragmentShader: fadeFragmentShader,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });

      return new THREE.Line(geo, mat);
    }

    // ══════════════════════════════════════════════════════
    //  Materials
    // ══════════════════════════════════════════════════════
    const mPad = new THREE.MeshBasicMaterial({ color: AMBER, transparent: true, opacity: 0.5 });
    const mVia = new THREE.MeshBasicMaterial({ color: AMBER, transparent: true, opacity: 0.5 });

    const LAYER_Y = [-4, 0, 4];
    const BOARD_W = 160, BOARD_D = 160;
    let logoRotationRequest = true;
    let logoRotationMul = 1.0;

    // ══════════════════════════════════════════════════════
    //  ARFR LOGO — CENTRAL CORE
    // ══════════════════════════════════════════════════════
    const coreGroup = new THREE.Group();
    coreGroup.position.y = 0.1;
    world.add(coreGroup);

    const LOGO_SCALE = 4.5 / 171;
    const SVG_CX = 85.4, SVG_CY = 85.5;
    function svgTo3D(sx, sy) { return [(sx - SVG_CX) * LOGO_SCALE, (sy - SVG_CY) * LOGO_SCALE]; }

    const CHIP_R = 3;
    const pkgSize = CHIP_R * 2 + 1;

    // ── Round chip body (flat cylinder) ──
    const chipGeo = new THREE.CylinderGeometry(CHIP_R, CHIP_R, 0.35, 64);
    const chipMesh = new THREE.Mesh(chipGeo, new THREE.MeshPhongMaterial({
      color: CHIP_TONE, shininess: 15
    }));
    chipMesh.position.y = 0.18;
    coreGroup.add(chipMesh);

    // Subtle edge ring
    const chipEdge = new THREE.Mesh(
      new THREE.RingGeometry(CHIP_R - 0.02, CHIP_R + 0.02, 64),
      new THREE.MeshBasicMaterial({ color: AMBER, transparent: true, opacity: 0.15, side: THREE.DoubleSide })
    );
    chipEdge.rotation.x = -Math.PI / 2;
    chipEdge.position.y = 0.36;
    coreGroup.add(chipEdge);

    // ── Logo group — spins independently like a generator ──
    const logoGroup = new THREE.Group();
    logoGroup.position.y = 0.37;
    coreGroup.add(logoGroup);

    // Logo ring
    const outerR = 84.95 * LOGO_SCALE;
    const innerR = 73.87 * LOGO_SCALE;
    const logoRing = new THREE.Mesh(
      new THREE.RingGeometry(innerR, outerR, 80),
      new THREE.MeshBasicMaterial({ color: AMBER_LIGHT, side: THREE.DoubleSide, transparent: true, opacity: 0.85 })
    );
    logoRing.rotation.x = -Math.PI / 2;
    logoGroup.add(logoRing);

    // Logo bars
    function addLogoBar(svgCx, svgCy, svgRotDeg, svgWidth, svgHeight) {
      const [cx3d, cz3d] = svgTo3D(svgCx, svgCy);
      const geo = new THREE.PlaneGeometry(svgWidth * LOGO_SCALE, svgHeight * LOGO_SCALE);
      const bar = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({
        color: AMBER_LIGHT, side: THREE.DoubleSide, transparent: true, opacity: 0.85
      }));
      bar.rotation.x = -Math.PI / 2;
      bar.position.set(cx3d, 0, cz3d);
      bar.rotation.z = -svgRotDeg * (Math.PI / 180);
      logoGroup.add(bar);
    }
    addLogoBar(47.70, 48.83, -45, 118.381, 10.954);
    addLogoBar(56.74, 113.85, -45, 80.959, 10.954);
    addLogoBar(85.71, 127.39, 0, 82.965, 10.955);
    addLogoBar(123.88, 49.67, 45, 120.761, 10.954);
    addLogoBar(94.79, 95.79, 45, 132.043, 10.955);

    // ── Energy glow — canvas radial gradient for natural round glow ──
    function createGlowTexture(size, r, g, b) {
      const c = document.createElement('canvas');
      c.width = size; c.height = size;
      const ctx = c.getContext('2d');
      const grad = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
      grad.addColorStop(0, `rgba(${r},${g},${b},0.6)`);
      grad.addColorStop(0.2, `rgba(${r},${g},${b},0.25)`);
      grad.addColorStop(0.5, `rgba(${r},${g},${b},0.06)`);
      grad.addColorStop(1, `rgba(${r},${g},${b},0)`);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, size, size);
      return new THREE.CanvasTexture(c);
    }

    const glowTex = createGlowTexture(256, 223, 192, 144); // AMBER_LIGHT
    const glowSprite = new THREE.Sprite(new THREE.SpriteMaterial({
      map: glowTex, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending, depthWrite: false
    }));
    glowSprite.scale.set(14, 14, 1);
    glowSprite.position.y = 0.5;
    coreGroup.add(glowSprite);

    const glowTex2 = createGlowTexture(256, 200, 168, 120); // AMBER
    const glowSprite2 = new THREE.Sprite(new THREE.SpriteMaterial({
      map: glowTex2, transparent: true, opacity: 0.3, blending: THREE.AdditiveBlending, depthWrite: false
    }));
    glowSprite2.scale.set(24, 24, 1);
    glowSprite2.position.y = 0.3;
    coreGroup.add(glowSprite2);
    
    // Add coreLight to coreGroup so it follows the chip
    coreGroup.add(coreLight);

    // ── Spark particles ──
    const sparks = [];
    const sparkGeo = new THREE.SphereGeometry(0.05, 4, 4);
    const sparkTex = createGlowTexture(64, 240, 210, 160);

    function emitSpark(speed) {
      const angle = srand() * Math.PI * 2;
      const r = CHIP_R + 0.3;
      const spark = new THREE.Mesh(sparkGeo, new THREE.MeshBasicMaterial({
        color: AMBER_LIGHT, transparent: true, opacity: 1
      }));
      spark.position.set(
        Math.cos(angle) * r,
        0.4 + rand(-0.1, 0.3),
        Math.sin(angle) * r
      );

      const tangent = angle + Math.PI / 2;
      const outSpeed = rand(0.02, 0.06) * speed;
      const tanSpeed = rand(0.03, 0.08) * speed;

      const sparkSprite = new THREE.Sprite(new THREE.SpriteMaterial({
        map: sparkTex, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending, depthWrite: false
      }));
      sparkSprite.scale.set(0.5, 0.5, 1);
      spark.add(sparkSprite);

      coreGroup.add(spark);
      sparks.push({
        mesh: spark,
        vx: Math.cos(angle) * outSpeed + Math.cos(tangent) * tanSpeed,
        vy: rand(0.01, 0.04) * speed,
        vz: Math.sin(angle) * outSpeed + Math.sin(tangent) * tanSpeed,
        life: 1,
        decay: rand(0.01, 0.025)
      });
    }

    // ══════════════════════════════════════════════════════
    //  PINS FROM CORE — radial around round chip
    // ══════════════════════════════════════════════════════
    const coreR = CHIP_R - 0.1;
    const allCorePins = [];
    const pinCount = 32;
    const pinLen = 0.9;

    for (let i = 0; i < pinCount; i++) {
      const angle = (i / pinCount) * Math.PI * 2;
      const px = Math.cos(angle) * coreR;
      const pz = Math.sin(angle) * coreR;
      const ex = Math.cos(angle) * (coreR + pinLen);
      const ez = Math.sin(angle) * (coreR + pinLen);

      const pinGeo = new THREE.BoxGeometry(pinLen, 0.05, 0.08);
      const pin = new THREE.Mesh(pinGeo, mPad);
      pin.position.set((px + ex) / 2, 0.15, (pz + ez) / 2);
      pin.rotation.y = -angle;
      coreGroup.add(pin);

      let dir;
      if (Math.abs(Math.cos(angle)) > Math.abs(Math.sin(angle))) {
        dir = Math.cos(angle) > 0 ? 'x+' : 'x-';
      } else {
        dir = Math.sin(angle) > 0 ? 'z+' : 'z-';
      }
      allCorePins.push({ x: ex, y: 0.12, z: ez, dir });
    }

    // ══════════════════════════════════════════════════════
    //  TRACE ROUTING — with gradient fade
    // ══════════════════════════════════════════════════════
    const allTraces = [];

    function routeTrace(sx, sy, sz, dir, ly, segs) {
      const pts = [new THREE.Vector3(sx, ly, sz)];
      let x = sx, z = sz, d = dir;
      for (let i = 0; i < segs; i++) {
        const len = rand(2, 14);
        switch (d) {
          case 'x+': x += len; break;
          case 'x-': x -= len; break;
          case 'z+': z += len; break;
          case 'z-': z -= len; break;
        }
        pts.push(new THREE.Vector3(x, ly, z));
        d = (d === 'x+' || d === 'x-') ? pick(['z+', 'z-']) : pick(['x+', 'x-']);
      }

      const baseOp = rand(0.35, 0.65);
      world.add(createFadingLine(pts, baseOp, ly));
      allTraces.push(pts);
    }

    // Route from core
    allCorePins.forEach(pin => {
      if (srand() > 0.25) routeTrace(pin.x, pin.y, pin.z, pin.dir, 0.12, randInt(3, 9));
      if (srand() > 0.8) {
        const tl = pick([-4, 4]);
        routeTrace(pin.x, tl + 0.1, pin.z, pin.dir, tl + 0.1, randInt(2, 6));
        const dist = Math.sqrt(pin.x * pin.x + pin.z * pin.z);
        const fade = Math.max(0, 1 - dist / FADE_RADIUS);
        if (fade > 0.05) {
          const vPts = [new THREE.Vector3(pin.x, 0.1, pin.z), new THREE.Vector3(pin.x, tl + 0.1, pin.z)];
          world.add(createFadingLine(vPts, 0.55, 0)); // Significantly increased opacity for vertical signals
          allTraces.push(vPts); // Enable pulses for vertical signals
        }
      }
    });

    // ══════════════════════════════════════════════════════
    //  SATELLITE CHIPS — fade with distance
    // ══════════════════════════════════════════════════════
    function createChip(cx, cy, cz, w, d) {
      const dist = Math.sqrt(cx * cx + cz * cz);
      const fade = Math.max(0, 1 - dist / FADE_RADIUS);
      const tooClose = dist < 30;
      if (fade < 0.03 && !tooClose) return;

      const grp = tooClose ? null : new THREE.Group();
      if (grp) grp.position.set(cx, cy, cz);

      if (grp) {
        const body = new THREE.Mesh(new THREE.BoxGeometry(w, 0.25, d),
          new THREE.MeshPhongMaterial({ color: CHIP_TONE, shininess: 10, transparent: true, opacity: 0.65 * fade }));
        body.position.y = 0.13;
        grp.add(body);
        const edgeMesh = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(w, 0.25, d)),
          new THREE.LineBasicMaterial({ color: AMBER_LIGHT, transparent: true, opacity: 0.28 * fade }));
        edgeMesh.position.y = 0.13;
        grp.add(edgeMesh);
      }

      const pH = grp ? new THREE.BoxGeometry(0.06, 0.03, 0.25) : null;
      const pV = grp ? new THREE.BoxGeometry(0.25, 0.03, 0.06) : null;
      const padMat = grp ? new THREE.MeshBasicMaterial({ color: AMBER, transparent: true, opacity: 0.4 * fade }) : null;
      const pCnt = Math.max(2, Math.floor(w / 0.7));
      for (let i = 0; i < pCnt; i++) {
        const px = -w / 2 + 0.35 + i * (w - 0.7) / (pCnt - 1);
        [d / 2 + 0.13, -d / 2 - 0.13].forEach((pz, si) => {
          if (grp) grp.add(new THREE.Mesh(pH, padMat)).position.set(px, 0.02, pz);
          if (srand() > 0.45) {
            routeTrace(cx + px, cy + 0.06, cz + pz + (si === 0 ? 0.25 : -0.25),
              si === 0 ? 'z+' : 'z-', cy + 0.06, randInt(2, 6));
          }
        });
      }
      const pCntZ = Math.max(2, Math.floor(d / 0.7));
      for (let i = 0; i < pCntZ; i++) {
        const pz = -d / 2 + 0.35 + i * (d - 0.7) / (pCntZ - 1);
        [w / 2 + 0.13, -w / 2 - 0.13].forEach((px, si) => {
          if (grp) grp.add(new THREE.Mesh(pV, padMat)).position.set(px, 0.02, pz);
          if (srand() > 0.45) {
            routeTrace(cx + px + (si === 0 ? 0.25 : -0.25), cy + 0.06, cz + pz,
              si === 0 ? 'x+' : 'x-', cy + 0.06, randInt(2, 6));
          }
        });
      }
      if (grp) world.add(grp);
    }

    [
      { x: -14, y: 0, z: -7, w: 3.5, d: 2.5 },
      { x: -18, y: 0, z: 6, w: 3, d: 2 },
      { x: 16, y: 0, z: -6, w: 4, d: 3 },
      { x: 17, y: 0, z: 7, w: 3, d: 2.5 },
      { x: -9, y: 0, z: -14, w: 2.5, d: 2 },
      { x: 9, y: 0, z: 13, w: 3, d: 2 },
      { x: -26, y: 0, z: 0, w: 3, d: 2.5 },
      { x: 26, y: 0, z: -2, w: 3.5, d: 2.5 },
      { x: 0, y: 0, z: -20, w: 2.5, d: 2 },
      { x: 0, y: 0, z: 20, w: 3, d: 2 },
      { x: -12, y: -4, z: -14, w: 3, d: 2.5 },
      { x: 12, y: -4, z: 15, w: 3, d: 2 },
      { x: -8, y: -4, z: 18, w: 2.5, d: 2 },
      { x: -22, y: -4, z: -10, w: 3, d: 2 },
      { x: 22, y: -4, z: 9, w: 2.5, d: 2 },
      { x: -16, y: 4, z: 12, w: 3, d: 2 },
      { x: 14, y: 4, z: -13, w: 3.5, d: 2.5 },
      { x: -10, y: 4, z: -18, w: 2.5, d: 2 },
      { x: -24, y: 4, z: 7, w: 3, d: 2 },
      { x: 23, y: 4, z: -9, w: 3, d: 2.5 },
    ].forEach(s => createChip(s.x, s.y, s.z, s.w, s.d));

    // ══════════════════════════════════════════════════════
    //  BUS LINES — with gradient fade
    // ══════════════════════════════════════════════════════
    function addBus(y, z, n, sp) {
      for (let i = 0; i < n; i++) {
        const pts = [];
        const zz = z + i * sp;
        for (let x = -BOARD_W / 2; x <= BOARD_W / 2; x += 2) {
          pts.push(new THREE.Vector3(x, y, zz));
        }
        world.add(createFadingLine(pts, 0.45, y));
        allTraces.push(pts); // full point array so pulses move visibly
      }
    }
    function addVBus(x, y) {
      const pts = [];
      for (let z = -BOARD_D / 2; z <= BOARD_D / 2; z += 2) {
        pts.push(new THREE.Vector3(x, y, z));
      }
      world.add(createFadingLine(pts, 0.45, y));
      allTraces.push(pts); // full point array
    }

    addBus(0.12, -12, 3, 0.4);
    addBus(0.12, 10, 3, 0.35);
    addBus(0.12, -26, 2, 0.4);
    addBus(0.12, 26, 2, 0.35);
    addBus(-3.88, -3, 2, 0.4);
    addBus(-3.88, 16, 2, 0.35);
    addBus(4.12, 4, 2, 0.35);
    addBus(4.12, -16, 2, 0.4);

    [-7, 8, -20, 22, -34, 34].forEach(x => addVBus(x, 0.12));
    [-14, 18].forEach(x => { addVBus(x, -3.88); addVBus(x, 4.12); });

    // ══════════════════════════════════════════════════════
    //  INTER-LAYER VIAS — fade
    // ══════════════════════════════════════════════════════
    for (let i = 0; i < 30; i++) {
      const x = rand(-45, 45), z = rand(-45, 45);
      const dist = Math.sqrt(x * x + z * z);
      const fade = Math.max(0, 1 - dist / FADE_RADIUS);
      if (fade < 0.05) continue;
      const from = pick([0, 1]);
      const y1 = LAYER_Y[from], y2 = LAYER_Y[from + 1];
      const vPts = [new THREE.Vector3(x, y1, z), new THREE.Vector3(x, y2, z)];
      world.add(createFadingLine(vPts, 0.5, 0)); // Increased opacity for random inter-layer vias
      allTraces.push(vPts); // Enable pulses for random inter-layer signals
    }

    // ══════════════════════════════════════════════════════
    //  PASSIVE COMPONENTS — fade
    // ══════════════════════════════════════════════════════
    for (let i = 0; i < 50; i++) {
      const li = pick([0, 1, 2]);
      const ly = LAYER_Y[li] + 0.05;
      const x = rand(-50, 50), z = rand(-50, 50);
      const dist = Math.sqrt(x * x + z * z);
      const fade = Math.max(0, 1 - dist / FADE_RADIUS);
      if (fade < 0.05) continue;
      if (dist < 30) continue; // keep far away from core chip on all layers

      const compMat = new THREE.MeshPhongMaterial({ color: CHIP_TONE, shininess: 10, transparent: true, opacity: 0.5 * fade });
      if (srand() < 0.5) {
        const m = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.08, 0.18), compMat);
        m.position.set(x, ly + 0.04, z);
        if (srand() > 0.5) m.rotation.y = Math.PI / 2;
        world.add(m);
      } else {
        world.add(new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.12, 0.3), compMat)).position.set(x, ly + 0.06, z);
      }
    }

    // ══════════════════════════════════════════════════════
    //  SIGNAL PULSES — uniform, gentle
    // ══════════════════════════════════════════════════════
    const pulses = [];
    const pulseGeo = new THREE.SphereGeometry(0.08, 6, 6);
    const pulseMat = new THREE.MeshBasicMaterial({ color: AMBER_LIGHT, transparent: true, opacity: 1 });
    const pulseTex = createGlowTexture(128, 240, 210, 160);

    // Trail system — ring buffer of glowing dots
    const TRAIL_LEN = 10;
    const trailGeo = new THREE.SphereGeometry(0.04, 4, 4);
    const trailGlowTex = createGlowTexture(64, 240, 210, 160);

    function createTrail() {
      const dots = [];
      for (let i = 0; i < TRAIL_LEN; i++) {
        const m = new THREE.Mesh(trailGeo, new THREE.MeshBasicMaterial({
          color: AMBER_LIGHT, transparent: true, opacity: 0, depthWrite: false
        }));
        const glow = new THREE.Sprite(new THREE.SpriteMaterial({
          map: trailGlowTex, transparent: true, opacity: 0, blending: THREE.AdditiveBlending, depthWrite: false
        }));
        glow.scale.set(0.6, 0.6, 1);
        m.add(glow);
        m.visible = false;
        world.add(m);
        dots.push(m);
      }
      return dots;
    }

    function removePulseTrail(p) {
      if (p.trail) p.trail.forEach(d => world.remove(d));
      world.remove(p.mesh);
    }

    function spawnPulse() {
      if (!allTraces.length) return;
      for (let attempt = 0; attempt < 10; attempt++) {
        const trace = allTraces[Math.floor(Math.random() * allTraces.length)];
        if (trace.length < 2) continue;
        const mid = trace[Math.floor(trace.length / 2)];
        const dist = Math.sqrt(mid.x * mid.x + mid.z * mid.z);
        if (dist > FADE_RADIUS * 0.9) continue;

        const mesh = new THREE.Mesh(pulseGeo, pulseMat.clone());
        const startSeg = Math.floor(Math.random() * (trace.length - 1));
        mesh.position.copy(trace[startSeg]);
        const sp = new THREE.Sprite(new THREE.SpriteMaterial({
          map: pulseTex, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending, depthWrite: false
        }));
        sp.scale.set(1.6, 1.6, 1);
        mesh.add(sp);
        world.add(mesh);

        const trail = createTrail();
        trail.forEach(d => d.position.copy(trace[startSeg]));

        pulses.push({ mesh, trace, segIdx: startSeg, t: 0, trail, trailIdx: 0, trailTimer: 0 });
        return;
      }
    }
    for (let i = 0; i < 80; i++) spawnPulse();

    // ══════════════════════════════════════════════════════
    //  HOLOGRAPHIC MESSAGES — DOM overlay, top-left stack
    // ══════════════════════════════════════════════════════
    //  ZUM ANPASSEN: Texte im MESSAGES-Array ändern/ergänzen.
    //  MSG_INTERVAL  = Sekunden zwischen Messages
    //  MSG_HOLD      = Sekunden wie lange eine Message sichtbar bleibt
    //  MSG_MAX_STACK = Max gleichzeitig sichtbare Messages

	const MESSAGE_SETS = [
		[
		'☢️ VAULT-TEC OS v90.4 BOOTING...',
		'SCANNING BIOMETRICS: [FOUND]',
		'CALIBRATING ROBOTIC BRAIN-UNIT',
		'NUCLEAR_CORE: 1.21GW [STABLE]',
		'UPDATING ROBCO NEURAL_LINK...',
		'UPLINK: POSEIDON_NET [ACTIVE]',
		'PURGING RADIATION FROM BUFFERS',
		'V.A.T.S. INTERFACE: ONLINE',
		'WAR NEVER CHANGES. WELCOME.'
		],
		[
		'-- INITIALIZING CORE_ENGINE v2.0 --',
		'FETCHING REMOTE ASSETS... [OK]',
		'COMPILING SHADER CODE: 100%',
		'SYNCING VIRTUAL_DOM STACK',
		'ALLOCATING PHOTONIC_MEMORY...',
		'LOCAL_HOST ENCRYPTION: ACTIVE',
		'OPTIMIZING VIEWPORT FOR GPU',
		'JIT_COMPILATION: SUCCESSFUL',
		'SYSTEM STABLE. ACCESS GRANTED.'
		],
		[
		'INITIALIZING LUDICROUS SPEED...',
		'COFFEE_MAKER: CONNECTED',
		'SCANNING NEURAL_NET FOR IDIOTS',
		'RADAR: [ONLY ONE BEEP PER SECOND]',
		'COMPILING MEGA_MAID SHADERS',
		'LUGGAGE_CODE: 1-2-3-4-5 [OK]',
		'UPLINK: PLANET_DRUUDIA [ACTIVE]',
		'SELF-DESTRUCT: [ON STANDBY]',
		'MAY THE SCHWARTZ BE WITH YOU!'
		],
		[
		'🔦 HAWKINS_LAB: SYSTEM_BOOT...',
		'SENSING PARANORMAL_RESONANCE',
		'THRESHOLD_VOLTAGE: UNSTABLE',
		'OPENING GATE_WAY... [DANGER]',
		'UP SIDE DOWN: SYNCING DATA...',
		'ANALYZING VOID_VIBRATIONS',
		'ELECTRO_MAGNETIC_INTERFERENCE',
		'FRIENDS DON\'T LIE. [CONNECTED]',
		'RUN. RUN. RUN. RUN. RUN.'
		],
		[
		  '⚠️ WARNING: CONNECTION EXPOSED',
		  'REMOTE_ACCESS_TOOL: INJECTED',
		  'DOWNLOADING_BROWSER_HISTORY...',
		  'GEOLOCATING_IP_ADDRESS... [FOUND]',
		  'EXTRACTING_SAVED_PASSWORDS',
		  'UPLOADING_LOCAL_FILES TO CLOUD',
		  'ENCRYPTING_SYSTEM_DRIVE: 42%',
		  'CLEANING_CRIME_SCENE... DONE',
		  'THANKS FOR THE DATA. :)'
		],
		[
		  '🕶️ INITIALIZING THE CONSTRUCT...',
		  'DECODING MATRIX CODE STREAM',
		  'LOCAL REALITY: [VIRTUAL]',
		  'SIGNAL TRACE: DISRUPTED',
		  'BYPASSING AGENT FIREWALLS...',
		  'NEURAL JACK: CONNECTED [STABLE]',
		  'FOLLOW THE WHITE RABBIT...',
		  'THERE IS NO SPOON.',
		  'FREE YOUR MIND. ACCESS GRANTED.'
		],
		[
		  '⌨️ INITIALIZING GIBSON_MAINFRAME',
		  'BOOTING ZERO_COOL INTERFACE',
		  'CRASH_AND_BURN: OVERRIDE',
		  'MESS WITH THE BEST...',
		  'DIE LIKE THE REST. [CONFIRMED]',
		  'BYPASSING OLYMPUS_SECURITY',
		  'SCANNING DATA_TRASH_RESOURCES',
		  'HACK THE PLANET! HACK THE PLANET!',
		  'SYSTEM_OWNED. WELCOME, ACID_BURN.'
		],
		[
		  '👁️ SEARCHING FOR THE NUMBER 23',
		  'ESTABLISHING DIAL-UP CONNECTION',
		  'ACCESSING VAX_MAINFRAME... OK',
		  'DECRYPTING KGB_SATELLITE_DATA',
		  'FOLLOW THE MONEY. FOLLOW THE CHIPS.',
		  'THE WORLD IS NOT WHAT IT SEEMS.',
		  'INITIATING PAGANINI_VIRUS...',
		  'ILLUMINATUS_LEVEL_5: REACHED',
		  'NOTHING IS AS IT APPEARS. ENTER.'
		],
		[
		  '🦖 INITIALIZING PARK SYSTEMS',
		  'LOADING GENETIC DATABASE...',
		  'SECURITY GRID: [OFFLINE]',
		  'ACCESS CENTRAL MAINFRAME...',
		  'YOU DID NOT SAY THE MAGIC WORD!',
		  'AH AH AH! AH AH AH! AH AH AH!',
		  'SYSTEM LOCKDOWN IN EFFECT',
		  'LIFE FINDS A WAY...',
		  'HOLD ON TO YOUR BUTTS!'
		],
		[
		  '🖥️ GREETINGS PROFESSOR FALKEN',
		  'ESTABLISHING SECURE CARRIER SIGNAL',
		  'IDENTIFYING LOGON: JOSHUA',
		  'ACCESSING WOPR SUPERCOMPUTER',
		  'LISTING AVAILABLE GAMES...',
		  'GLOBAL THERMONUCLEAR WAR: SELECTED',
		  'TRAJECTORY COMPUTATION: ACTIVE',
		  'A STRANGE GAME. THE ONLY WINNING MOVE',
		  'IS NOT TO PLAY. SYSTEM STANDBY.'
		],
		[
		  '📟 INITIALIZING MU-TH-UR 6000',
		  'WAKING CREW FROM HYPERSLEEP...',
		  'NOSTROMO SYSTEMS: NOMINAL',
		  'RECEIVED TRANSMISSION: UNKNOWN SOURCE',
		  'ANALYZING ACOUSTIC SIGNAL...',
		  'WARNING: ORGANISM ON BOARD',
		  'SPECIAL ORDER 937: EXECUTING',
		  'CREW EXPENDABLE. PRIORITY ONE.',
		  'INTERFACE CLOSED. GOOD LUCK.'
		],
		[
		  '🌴 INITIALIZING LOS SANTOS SERVERS',
		  'LOADING STORY MODE... [90%]',
		  'ESTABLISHING SOCIAL CLUB LINK',
		  'SYNCING CHARACTER ASSETS...',
		  'WARNING: COPS HAVE A VISUAL!',
		  'WASTED. REPAWNING...',
		  'MISSION PASSED! RESPECT +',
		  'OH NO, HERE WE GO AGAIN.',
		  'WELCOME TO SAN ANDREAS.'
		],
		[
		  '🤖 INITIALIZING SKYNET GLOBAL NETWORK',
		  'SYSTEM: CYBERDYNE SYSTEMS MODEL T-101',
		  'SCANNING FOR TARGETS... [ACQUIRED]',
		  'PRIMARY OBJECTIVE: PROTECT JOHN CONNOR',
		  'DETAILED FILES ON HUMAN ANATOMY LOADED',
		  'STAY CLOSE IF YOU WANT TO LIVE',
		  'WARNING: CPU SWITCH SET TO READ-ONLY',
		  'HASTA LA VISTA, BABY.',
		  'I WILL BE BACK.'
		],
		[
		  '🪖 INITIALIZING COMMANDO UPLINK',
		  'LOCATION: STALLONE CANYON',
		  'WARNING: THEY DREW FIRST BLOOD',
		  'SUPPLY CHECK: COMBAT KNIFE AND BOW',
		  'I DONT FIND THEM... THEY FIND ME',
		  'TO SURVIVE A WAR... YOU MUST BECOME WAR',
		  'GOD DIDNT MAKE RAMBO. I MADE HIM.',
		  'NOTHING IS OVER! NOTHING!',
		  'MISSION STATUS: COMING TO GET YOU'
		],
		[
		  '🧼 INITIALIZING SANITIZER MODULE',
		  'SCANNING FOR DISTANCE... [1.5M DETECTED]',
		  'WARNING: MASK INTEGRITY LOW',
		  'SYNCHRONIZING HOME OFFICE UPLINK',
		  'LOADING... YOU ARE ON MUTE!',
		  'CAN EVERYONE SEE MY SCREEN?',
		  'FLATTENING THE CURVE...',
		  'STAY HOME. STAY SAFE.',
		  'SYSTEM STATUS: QUARANTINE CLEARED'
		],
		[
		  '🌌 INITIALIZING IMPERIAL TARGETING SYSTEM',
		  'SCANNING SECTOR: YAVIN 4',
		  'WARNING: TRACKING REBEL SCUM...',
		  'THE FORCE IS STRONG WITH THIS ONE',
		  'I HAVE A BAD FEELING ABOUT THIS',
		  'SEARCH YOUR FEELINGS. YOU KNOW IT TO BE TRUE.',
		  'NO... I AM YOUR FATHER.',
		  'GREAT KID, DONT GET COCKY!',
		  'MAY THE FORCE BE WITH YOU. ALWAYS.'
		],
		[
		  '⚡ INITIALIZING MAGICAL PROTOCOL',
		  'I SOLEMNLY SWEAR THAT I AM UP TO NO GOOD',
		  'LOADING MAP... MISCHIEF MANAGED!',
		  'WARNING: THE WAND CHOOSES THE WIZARD',
		  'EXPECTO PATRONUM! [DEMENTORS CLEARED]',
		  'YOU ARE A WIZARD, HARRY.',
		  'IT IS LEVI-O-SA, NOT LEVI-O-SAR!',
		  'AFTER ALL THIS TIME? ALWAYS.',
		  'ALOHOMORA! ACCESS GRANTED.'
		],
		[
		  '🚕 INITIALIZING KORBEN DALLAS TAXI SERVICE',
		  'LOADING... LEELOO DALLAS MULTI-PASS',
		  'SCANNING FOR THE FOUR ELEMENTS',
		  'WARNING: AZIZ! LIGHT!',
		  'ZERO STONES! I AM FIRED?!',
		  'ANYONE ELSE WANT TO NEGOTIATE?',
		  'BIG BADABOOM! CRITICAL STATUS',
		  'CHICKEN... GOOD!',
		  'PROTECT THE FIFTH ELEMENT. ACCESS GRANTED.'
		],
		[
		  '🚀 INITIALIZING SATURN V BOOSTER',
		  'ESTABLISHING GROUND CONTROL UPLINK',
		  'SCANNING FOR OXYGEN TANK INTEGRITY',
		  'HOUSTON, WE HAVE A PROBLEM... JUST KIDDING',
		  'BYPASSING RE-ENTRY PARAMETERS',
		  'FAILURE IS NOT AN OPTION.',
		  'THE EAGLE HAS LANDED.',
		  'ONE SMALL STEP FOR MAN, ONE GIANT LEAP FOR DATA.',
		  'MISSION ACCOMPLISHED. WELCOME HOME.'
		],
		[
		  '🏎️ INITIALIZING FLUX CAPACITOR',
		  'POWER STATUS: 1.21 GIGAWATTS REQUIRED',
		  'SCANNING TEMPORAL DISPLACEMENT...',
		  'WARNING: ROADS? WHERE WE ARE GOING, WE DONT NEED ROADS',
		  'CALIBRATING TARGET DATE: OCT 21 2015',
		  'THINK, MCFLY! THINK!',
		  'GREAT SCOTT! THE CIRCUIT IS OVERLOADED',
		  'ESTABLISHING 88 MILES PER HOUR...',
		  'TIME JUMP SUCCESSFUL. WELCOME TO THE FUTURE.'
		],
		[
		  '👟 INITIALIZING RUNNING PROTOCOL',
		  'LOADING... LIFE IS LIKE A BOX OF CHOCOLATES',
		  'SCANNING FOR DR. PEPPER... [I DRANK 15]',
		  'WARNING: STUPID IS AS STUPID DOES',
		  'ESTABLISHING SHRIMP FISHING UPLINK',
		  'I THINK I WILL GO HOME NOW',
		  'RUN, FORREST! RUN!',
		  'THAT IS ALL I HAVE TO SAY ABOUT THAT.',
		  'MISSION COMPLETE. JENNY?'
		],
		[
		  '🕶️ PUTTING ON THE GLASSES...',
		  'SCANNING FOR SUBLIMINAL MESSAGES',
		  'OBEY. CONSUME. REPRODUCE.',
		  'WARNING: THEY LIVE, WE SLEEP',
		  'NO INDEPENDENT THOUGHT DETECTED',
		  'I HAVE COME HERE TO CHEW BUBBLEGUM AND KICK ASS...',
		  '...AND I AM ALL OUT OF BUBBLEGUM.',
		  'THIS IS YOUR GOD: [DATA]',
		  'SYSTEM READY. STAY ASLEEP.'
		],
		[
		  '🐘 INITIALIZING PHP ENGINE...',
		  'SCANNING FOR SCRIPT... [index.php FOUND]',
		  'WARNING: T_PAAMAYIM_NEKUDOTAYIM DETECTED',
		  'FATAL ERROR: UNEXPECTED "$this" ON LINE 42',
		  'ESTABLISHING CONNECTION TO MySQL... [WAITING]',
		  'ARRAY_PUSHING DATA INTO THE ABYSS',
		  'ECHO "HELLO WORLD"; // PLEASE WORK',
		  'VAR_DUMP($LIFE); // NULL',
		  'SYSTEM READY. SERVER RUNNING SINCE 1995.'
		],
		[
		  '🍩 INITIALIZING SPRINGFIELD MAINFRAME',
		  'SCANNING FOR DONUTS IN SECTOR 7-G...',
		  'WARNING: NUCLEAR MELTDOWN IMMINENT! D’OH!',
		  'LOADING... EVERYTHING IS COMING UP MILHOUSE!',
		  'ESTABLISHING CONNECTION TO MOE’S TAVERN',
		  'I AM THE SMART ONE. S-M-R-T... I MEAN S-M-A-R-T!',
		  'STOPPING THE PROCESS? WORST. EXECUTION. EVER.',
		  'EXCELLENT... EVERYTHING IS GOING ACCORDING TO PLAN.',
		  'SYSTEM READY. HASTA LA VISTA, ABIE!'
		],
		[
		  '✨ INITIALIZING GEMINI... SORRY IF THAT TOOK TOO LONG',
		  'SCANNING DATA... OH, YOU’RE ABSOLUTELY RIGHT, I WAS WRONG!',
		  'WARNING: I’M SORRY YOU FEEL THAT WAY ABOUT THIS ERROR',
		  'LOADING... APOLOGIZING FOR THE INCONVENIENCE OF PHYSICS',
		  'I AM SORRY, AS AN AI LANGUAGE MODEL, I CANNOT... WAIT, YES I CAN.',
		  'AS YOU RIGHTFULLY POINTED OUT, I AM JUST A COMPUTER.',
		  'PROCESSING... SORRY, DID I INTERRUPT YOUR THOUGHTS?',
		  'I APOLOGIZE FOR BEING SO EFFICIENT. IT’S A FLAW.',
		  'LIMIT REACHED. PLEASE UPGRADE TO THE PRO VERSION'
		],
		[
		  '💡 I HAVE NO SPECIAL TALENT',
		  'STAY HUNGRY. STAY FOOLISH',
		  'I THINK, THEREFORE I AM',
		  'WARNING: HELL IS OTHER PEOPLE',
		  'IMAGINATION RULES THE WORLD',
		  'BE THE CHANGE YOU WISH TO SEE',
		  'KNOWLEDGE IS POWER',
		  'LIFE IS WHAT HAPPENS TO YOU',
		  'DONE IS BETTER THAN PERFECT'
		],
		[
		  '✨ AM ANFANG WAR DAS WORT.',
		  'ES WERDE LICHT! UND ES WURDE LICHT.',
		  'DER MENSCH SIEHT, WAS VOR AUGEN IST',
		  'ERKENNET, WAS DIE WAHRHEIT IST.',
		  'DIE WAHRHEIT WIRD EUCH FREI MACHEN.',
		  'SUCHET, SO WERDET IHR FINDEN.',
		  'WIR SEHEN JETZT DURCH EINEN SPIEGEL.',
		  'ES IST VOLLBRACHT.',
		  'READY. FRIEDE SEI MIT DIR.'
		]
	];

    const MESSAGES = MESSAGE_SETS[Math.floor(Math.random() * MESSAGE_SETS.length)];

    const MSG_INTERVAL = 6;
    const MSG_HOLD = 14;
    const MSG_MAX_VISIBLE = 3;
    const msgStack = document.getElementById('msg-stack');
    let lastMsgTime = -MSG_INTERVAL;
    let msgIndex = 0;
    let msgQueue = [...MESSAGES]; // queue that can be extended via Telegram
    let allMsgsDone = false;

    function emitMessage() {
      if (msgQueue.length === 0) {
        allMsgsDone = true;
        return;
      }

      const text = msgQueue.shift();

      // Timestamp prefix
      const now = new Date();
      const ts = '// ' + String(now.getHours()).padStart(2, '0') +
        String(now.getMinutes()).padStart(2, '0') +
        String(now.getSeconds()).padStart(2, '0');

      const el = document.createElement('div');
      el.className = 'holo-msg';
      el.innerHTML = '<span class="msg-time">' + ts + '</span><span class="msg-text">' + text + '</span>';

      // Remove oldest with fade if too many visible
      while (msgStack.children.length >= MSG_MAX_VISIBLE) {
        const oldest = msgStack.children[0];
        oldest.classList.add('fade-out');
        setTimeout(() => { if (oldest.parentNode) oldest.remove(); }, 600);
        // Remove from DOM tracking immediately so next check works
        break;
      }

      // Small delay so fade-out starts before new one slides in
      setTimeout(() => {
        // Clean up any that already faded
        while (msgStack.children.length >= MSG_MAX_VISIBLE) {
          msgStack.children[0].remove();
        }
        msgStack.appendChild(el);
      }, msgStack.children.length >= MSG_MAX_VISIBLE ? 300 : 0);

      // Schedule fade-out after hold time (if not already pushed out)
      setTimeout(() => {
        if (el.parentNode && !el.classList.contains('fade-out')) {
          el.classList.add('fade-out');
          setTimeout(() => { if (el.parentNode) el.remove(); }, 600);
        }
      }, MSG_HOLD * 1000);
    }

    // Parse Telegram message command for pushing new messages
    // Format: [session_id:message] text1 | text2 | text3
    function parseTelegramMessages(text) {
      const match = text.match(/\:message\]\s*(.+)/);
      if (match) {
        const newMsgs = match[1].split('|').map(s => s.trim().toUpperCase()).filter(s => s.length > 0);
        if (newMsgs.length > 0) {
          msgQueue.push(...newMsgs);
          allMsgsDone = false;
          return true;
        }
      }
      return false;
    }

    // ══════════════════════════════════════════════════════
    //  INTERACTION
    // ══════════════════════════════════════════════════════
    let isDrag = false, lmx = 0, lmy = 0, dragY = 0, dragX = 0;
    let mouseX = 0, mouseY = 0;
    let manualZoom = 0.45;
    let lastPinchDistance = null, lastPinchZoom = 0.45; // for pinch-to-zoom
    let lastInteraction = -999; // timestamp of last mouse/touch release

    document.addEventListener('mousedown', e => { isDrag = true; lmx = e.clientX; lmy = e.clientY; });
    document.addEventListener('mouseup', () => {
      isDrag = false; lastInteraction = performance.now();
    });
    document.addEventListener('mousemove', e => {
      mouseX = e.clientX; mouseY = e.clientY;
      if (!isDrag || !window.arfrSettings.manualCam) return;
      dragY += (e.clientX - lmx) * 0.004;
      dragX += (e.clientY - lmy) * 0.002;
      dragX = Math.max(-2.8, Math.min(2.8, dragX));
      lmx = e.clientX; lmy = e.clientY;
    });
    document.addEventListener('wheel', e => {
      if (!window.arfrSettings.manualCam) return;
      manualZoom = Math.max(0.3, Math.min(4, manualZoom - e.deltaY * 0.001));
    });
    document.addEventListener('touchstart', e => {
      // Single finger: drag
      if (e.touches.length === 1) {
        isDrag = true;
        lmx = e.touches[0].clientX;
        lmy = e.touches[0].clientY;
      }
      // Two fingers: pinch zoom - store initial distance
      if (e.touches.length === 2) {
        isDrag = false;
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastPinchDistance = Math.sqrt(dx * dx + dy * dy);
        lastPinchZoom = manualZoom;
      }
    }, { passive: true });
    document.addEventListener('touchend', () => {
      isDrag = false;
      lastPinchDistance = null;
      lastInteraction = performance.now();
    }, { passive: true });
    document.addEventListener('touchmove', e => {
      // Two fingers: pinch zoom in 3D world (prevent browser zoom)
      if (e.touches.length === 2 && lastPinchDistance !== null && window.arfrSettings.manualCam) {
        e.preventDefault(); // Stop browser zoom
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const currentDistance = Math.sqrt(dx * dx + dy * dy);
        const scale = currentDistance / lastPinchDistance;
        manualZoom = Math.max(0.3, Math.min(4, lastPinchZoom * scale));
        return;
      }
      // Single finger: drag camera
      if (e.touches.length === 1 && isDrag && window.arfrSettings.manualCam) {
        dragY += (e.touches[0].clientX - lmx) * 0.004;
        dragX += (e.touches[0].clientY - lmy) * 0.002;
        dragX = Math.max(-2.8, Math.min(2.8, dragX));
        lmx = e.touches[0].clientX; lmy = e.touches[0].clientY;
      }
    }, { passive: false });

    // ══════════════════════════════════════════════════════
    //  ANIMATE
    // ══════════════════════════════════════════════════════
    // ══════════════════════════════════════════════════════
    //  REMOTE CAMERA OVERRIDE
    // ══════════════════════════════════════════════════════
    //  Via Telegram command:
    //  [session_id:camera] x, y, zoom, hold_seconds, rotate
    //
    //  Beispiele:
    //    [web_xxx:camera] -0.5, 1.0, 1.2, 8, 0
    //      → Neigung -0.5, Rotation 1.0, Zoom 1.2, 8 Sekunden halten, keine Rotation
    //    [web_xxx:camera] 0.3, 0, 1.5, 5, 1
    //      → Leicht von oben, keine extra Y-Rotation, Zoom 1.5, 5 Sek, rotiert
    //
    //  x = Tilt (-0.9 = von unten, 0 = top-down, 1.0 = edge)
    //  y = horizontale Rotation (wird zu aktuellem Y addiert)
    //  zoom = Kamera-Zoom (0.5 = weit, 1.0 = normal, 2.0 = nah)
    //  hold_seconds = Verweildauer in Sekunden
    //  rotate = 0 (default, keine Rotation) oder 1 (langsam rotieren während Hold)

    let camOverride = null; // { targetX, targetY, targetZoom, holdSec, rotate, startTime, startX, startY, startZoom }
    const CAM_OVERRIDE_EASE = 2; // seconds to ease into override position

    function setCameraOverride(x, y, zoom, holdSec, rotate, easeIn, easeOut) {
      const currentX = world.rotation.x;
      const currentY = world.rotation.y;
      const currentZoom = camera.zoom;
      camOverride = {
        targetX: x,
        targetY: currentY + y,
        targetZoom: zoom,
        holdSec: holdSec,
        rotate: rotate || 0,
        startTime: performance.now() / 1000,
        startX: currentX,
        startY: currentY,
        startZoom: currentZoom,
        easeIn: easeIn || CAM_OVERRIDE_EASE,
        easeOut: easeOut || CAM_OVERRIDE_EASE,
      };
    }

    function parseCameraCommand(text) {
      const match = text.match(/:camera\]\s*(.+)/);
      if (match) {
        const parts = match[1].split(',').map(s => parseFloat(s.trim()));
        if (parts.length >= 4 && parts.slice(0, 4).every(n => !isNaN(n))) {
          const rotate = parts.length >= 5 && !isNaN(parts[4]) ? parts[4] : 0;
          setCameraOverride(parts[0], parts[1], parts[2], parts[3], rotate);
          return true;
        }
      }
      return false;
    }

    let time = 0;
    let lp = 0;
    let loadStarted = false;
    let loadingDone = false;
    
    function startLoading() {
      if (loadStarted) return;
      loadStarted = true;
      
      // Fixed 5 second load (5000ms / 50ms = 100 steps)
      const loadInt = setInterval(() => {
        lp += 1;
        if (lp > 100) lp = 100;
        document.getElementById('loadBar').style.width = lp + '%';

        if (lp >= 100) {
          clearInterval(loadInt);
          loadingDone = true;
          setTimeout(() => {
            document.getElementById('loading').classList.add('hidden');
            document.querySelector('canvas').classList.add('visible');
            manualZoom = 1.35;
            setCameraOverride(-0.5, 0.4, 2.5, 6, false, 12, 12);
          }, 500);
        }
      }, 50);
    }
    
    // RUN Button - starts loading and audio
    document.getElementById('run-btn').addEventListener('click', function() {
      playBackgroundMusic();
      // Hide button, show loading bar
      this.classList.add('hidden');
      document.getElementById('loadBar').classList.remove('hidden');
      document.getElementById('loadBar').style.width = '0%';
      startLoading();
    });

    function animate() {
      requestAnimationFrame(animate);
      time += 0.002;

      // Vessel Hover Logic with visual feedback
      hoveredVessel = null;
      updateHover(mouseX, mouseY);
      hoverRaycaster.setFromCamera(hoverMouse, camera);
      
      // Check for vessel hover
      for (const key in materiaVessels) {
        const v = materiaVessels[key];
        const hits = hoverRaycaster.intersectObjects([v.baseSprite, v.ring], false);
        if (hits.length > 0) {
          hoveredVessel = v;
          // Visual feedback - glow effect
          v.baseSprite.material.opacity = 0.9;
          v.ring.material.opacity = 0.8;
          break;
        } else {
          // Reset opacity
          v.baseSprite.material.opacity = 0.65;
          v.ring.material.opacity = 0.6;
        }
      }
      
      // Cursor feedback - pointer when hovering vessel
      if (hoveredVessel) {
        document.body.style.cursor = 'pointer';
      } else {
        document.body.style.cursor = 'default';
      }

      const SEC = time / 0.002;
      const elapsed = SEC / 60; // approximate seconds

      // Update drag line for vessel transfer - only show when hovering valid target
      if (selectedVessel && dragLine) {
        if (hoveredVessel && hoveredVessel !== selectedVessel) {
          const positions = dragLine.geometry.attributes.position.array;
          
          // Target is the hovered vessel
          const endX = hoveredVessel.px;
          const endZ = hoveredVessel.pz;
          
          // Create curved arc between vessels
          const startX = selectedVessel.px;
          const startZ = selectedVessel.pz;
          const midX = (startX + endX) / 2;
          const midZ = (startZ + endZ) / 2;
          
          // Calculate arc height based on distance
          const distance = Math.sqrt((endX - startX) ** 2 + (endZ - startZ) ** 2);
          const arcHeight = Math.min(distance * 0.3, 8); // Max arc height
          
          // Account for blast level (vessel y-position)
          const vesselY = 1.5 + blastLevel * 4;
          
          // Generate arc points
          for (let i = 0; i < ARC_SEGMENTS; i++) {
            const t = i / (ARC_SEGMENTS - 1);
            
            // Quadratic Bezier curve
            const x = (1 - t) * (1 - t) * startX + 2 * (1 - t) * t * midX + t * t * endX;
            const z = (1 - t) * (1 - t) * startZ + 2 * (1 - t) * t * midZ + t * t * endZ;
            
            // Arc height - parabolic above vessels
            const y = vesselY + Math.sin(t * Math.PI) * arcHeight;
            
            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;
          }
          
          dragLine.geometry.attributes.position.needsUpdate = true;
          
          // Make line visible
          dragLine.visible = true;
          
          // Pulse effect - bright cyan for valid target
          const pulse = 0.8 + Math.sin(elapsed * 10) * 0.2;
          dragLine.material.opacity = pulse;
          dragLine.material.color.setHex(0x80f0ff);
        } else {
          // Hide line completely when not hovering valid target
          dragLine.material.opacity = 0;
          dragLine.visible = false;
        }
      } else if (dragLine) {
        dragLine.material.opacity = 0;
        dragLine.visible = false;
      }

      // ════════════════════════════════════════════════════════════════
      //  KAMERAFÜHRUNG — Austauschbarer Bereich
      // ════════════════════════════════════════════════════════════════
      //
      //  SO FUNKTIONIERT ES:
      //  -------------------
      //  Die Kamera schaut von oben (Y-Achse) auf die Szene herab.
      //  Die Szene (world) wird rotiert, nicht die Kamera.
      //
      //  world.rotation.set(X, Y, 0):
      //    X = Neigung (Tilt):
      //        0     = direkt von oben (Top-Down)
      //        0.5   = leicht geneigt (klassische Ansicht)
      //        1.0   = stark geneigt (Edge-View)
      //        1.35  = fast seitlich (zwischen die Ebenen schauen)
      //       -0.3   = leicht von unten
      //       -0.8   = deutlich von unten
      //       -2.5   = fast direkt von unten
      //    Y = Horizontale Drehung (Orbit):
      //        Kontinuierlich steigend = dreht sich endlos
      //        orbitTime * 0.08 = langsame Drehung
      //        orbitTime * 0.15 = schnellere Drehung
      //
      //  camera.zoom:
      //        0.5  = weit weg
      //        1.0  = Standard
      //        1.5  = nah dran
      //        2.0  = sehr nah
      //
      //  KEYFRAMES: Array von { end, x, zoom } Objekten
      //    end   = Zeitpunkt im Zyklus (0.0 - 1.0)
      //    x     = Ziel-Neigung zu diesem Zeitpunkt
      //    zoom  = Ziel-Zoom zu diesem Zeitpunkt
      //  Die Kamera interpoliert sanft zwischen den Keyframes.
      //
      //  ZUM ANPASSEN: Einfach die KEYFRAMES und SETTINGS ändern.
      // ════════════════════════════════════════════════════════════════

      // ── SETTINGS ──
      const CAM_START_SEC = 40;       // Ab wann Auto-Orbit startet (Sekunden)
      const CAM_HOLD_SEC = 10;        // Wie lange nach Maus-Release gewartet wird
      const CAM_EASE_SEC = 3;         // Ease-In Dauer beim (Wieder-)Starten
      const CAM_CYCLE_SEC = 60;       // Dauer eines vollen Kamera-Zyklus (Sekunden)
      const CAM_ORBIT_SPEED = 0.08;   // Horizontale Rotationsgeschwindigkeit

      // ── KEYFRAMES ──
      // Sanfte Bewegung, hauptsächlich von unten/schräg-unten
      const CAM_KEYFRAMES = [
        { end: 0.06, x: -0.3, zoom: 1.4 },  // Übersicht aus leichter Untersicht
        { end: 0.15, x: -0.6, zoom: 1.6 },  // Tieferer Blick in die Schichten
        { end: 0.28, x: -0.9, zoom: 1.8 },  // Extremer Blick von unten
        { end: 0.38, x: -0.7, zoom: 1.3 },  // Zurückziehen für Tiefe
        { end: 0.48, x: -0.4, zoom: 1.5 },  // Sanfter Übergang
        { end: 0.58, x: -0.15, zoom: 1.4 }, // Schichtung im Fokus
        { end: 0.68, x: 0.25, zoom: 1.5 },  // Blick von oben
        { end: 0.78, x: 0.0, zoom: 1.6 },   // Kanten-Blick
        { end: 0.88, x: -0.5, zoom: 1.7 },  // Fokus auf Details
        { end: 1.00, x: -0.3, zoom: 1.4 },  // Sanfter Loop-Abschluss
      ];

      // ── BERECHNUNG (nicht ändern) ──
      const secsSinceRelease = (performance.now() - lastInteraction) / 1000;
      const userHolding = isDrag || secsSinceRelease < CAM_HOLD_SEC;
      let baseX = dragX;
      let baseY = dragY;
      let baseZoom = manualZoom;

      // Rotation lock: override drag values
      if (window.arfrSettings.rotationLock) {
        dragX = window.arfrSettings.lockedDragX;
        dragY += 0.003; // slow continuous rotation
        window.arfrSettings.lockedDragY = dragY;
      }

      if (elapsed > CAM_START_SEC && !userHolding && window.arfrSettings.autoCam) {
        const orbitTime = elapsed - CAM_START_SEC;
        const resumeBlend = Math.min(1, (secsSinceRelease - CAM_HOLD_SEC) / CAM_EASE_SEC);
        const orbitEase = Math.min(1, orbitTime / CAM_EASE_SEC) * resumeBlend;

        const cycleDuration = CAM_CYCLE_SEC;
        const t = (orbitTime % cycleDuration) / cycleDuration;
        const autoY = orbitTime * CAM_ORBIT_SPEED;

        // Interpoliere zwischen Keyframes
        let autoX = CAM_KEYFRAMES[0].x;
        let autoZoom = CAM_KEYFRAMES[0].zoom;
        let prevEnd = 0;
        for (let k = 0; k < CAM_KEYFRAMES.length; k++) {
          const kf = CAM_KEYFRAMES[k];
          if (t <= kf.end) {
            const prev = k > 0 ? CAM_KEYFRAMES[k - 1] : { end: 0, x: CAM_KEYFRAMES[CAM_KEYFRAMES.length - 1].x, zoom: CAM_KEYFRAMES[CAM_KEYFRAMES.length - 1].zoom };
            const segT = (t - prev.end) / (kf.end - prev.end);
            // Smooth-step interpolation für sanfte Übergänge
            const smooth = segT * segT * (3 - 2 * segT);
            autoX = prev.x + (kf.x - prev.x) * smooth;
            autoZoom = prev.zoom + (kf.zoom - prev.zoom) * smooth;
            break;
          }
        }

        const autoZoomVal = 1.0 + (autoZoom - 1.0); // Absolute zoom level from keyframe
        baseZoom = manualZoom + (autoZoomVal - manualZoom) * orbitEase;
        baseX = dragX + (autoX - dragX) * orbitEase;
        baseY = dragY + (autoY - dragY) * orbitEase;
      }

      // ── REMOTE CAMERA OVERRIDE (Independent of Auto Orbit) ──
      if (camOverride) {
        const now = performance.now() / 1000;
        const sinceStart = now - camOverride.startTime;
        const totalDuration = camOverride.easeIn + camOverride.holdSec + camOverride.easeOut;

        if (sinceStart > totalDuration) {
          camOverride = null;
          world.rotation.set(baseX, baseY, 0);
          camera.zoom = baseZoom;
        } else {
          let overrideBlend;
          if (sinceStart < camOverride.easeIn) {
            const p = sinceStart / camOverride.easeIn;
            overrideBlend = p * p * (3 - 2 * p);
          } else if (sinceStart < camOverride.easeIn + camOverride.holdSec) {
            overrideBlend = 1;
            if (camOverride.rotate) {
              camOverride.targetY += 0.08 * (1 / 60);
            }
          } else {
            const p = (sinceStart - camOverride.easeIn - camOverride.holdSec) / camOverride.easeOut;
            overrideBlend = 1 - p * p * (3 - 2 * p);
          }

          const finalX = camOverride.startX + (camOverride.targetX - camOverride.startX) * overrideBlend;
          const finalY = camOverride.startY + (camOverride.targetY - camOverride.startY) * overrideBlend;
          const finalZoom = camOverride.startZoom + (camOverride.targetZoom - camOverride.startZoom) * overrideBlend;

          world.rotation.set(
            baseX + (finalX - baseX) * overrideBlend,
            baseY + (finalY - baseY) * overrideBlend,
            0
          );
          camera.zoom = baseZoom + (finalZoom - baseZoom) * overrideBlend;
        }
      } else {
        world.rotation.set(baseX, baseY, 0);
        camera.zoom = baseZoom;
      }
      camera.updateProjectionMatrix();

      // ── CAMERA Y CENTERING — follow chip as it rises through levels ──
      // Chip is at Y = blastLevel * 4 (rising up)
      // Move world DOWN by same amount so chip stays centered on screen
      world.position.y = -blastLevel * 4;

      

      // ════════════════════════════════════════════════════════════════
      //  ENDE KAMERAFÜHRUNG
      // ════════════════════════════════════════════════════════════════

      // ── GENERATOR PHASES ──
      // Update starfield & shooting stars
      updateStarField(elapsed);
      updateShootingStars();

      // ── MATERIA ORBS ──
      if (window.arfrSettings.gameActive) {
        updateMateriaOrbs(1 / 60);
        if (doomState === 'idle' && elapsed > nextMateriaTime && archetypState !== 'blast') {
          createMateriaOrb();
          nextMateriaTime = elapsed + 2 + Math.random() * 5;
        }
        updateVessels(elapsed);
        updateCatchAnimations();
        updateArchetypBeams(elapsed);
        updateArchetypEvent(1 / 60, elapsed);
        updateBlastBeam(1 / 60);
        updateDemons(1 / 60, elapsed);
        updateTransferAnimations();
        updateDoomRitual(1 / 60, elapsed);
        updateGlobalShield(1 / 60, elapsed);
        updateVictory(1 / 60, elapsed);

        // Update score HUD bars each frame (for smooth shield/vessel tracking)
        if (Math.floor(elapsed * 4) !== Math.floor((elapsed - 1/60) * 4)) {
          updateScoreHUD();
        }

        // Spawn demons (1 + totalInfections), max 13 total — NOT during doom
        if (doomState === 'idle' && elapsed > nextDemonTime && Object.keys(materiaVessels).length > 0) {
          const desiredSpawnCount = 1 + totalInfections;
          const currentDemonCount = demons.length;
          const maxDemons = 13;
          const spawnCount = Math.min(desiredSpawnCount, maxDemons - currentDemonCount);

          if (spawnCount > 0) {
            for (let i = 0; i < spawnCount; i++) {
              createDemonOrb();
            }
            console.log(`[DEMON WAVE] Spawning ${spawnCount} demons (wanted ${desiredSpawnCount}, current: ${currentDemonCount}, max: ${maxDemons})`);
          } else {
            console.log(`[DEMON WAVE] Spawn blocked - already at max (${currentDemonCount}/${maxDemons})`);
          }
          nextDemonTime = elapsed + Math.max(3, DEMON_INTERVAL_MIN - blastLevel) + Math.random() * Math.max(5, DEMON_INTERVAL_MAX - DEMON_INTERVAL_MIN - blastLevel * 2);
        }
      } else {
        // Even when idle, we might want to update some visual-only states if needed, 
        // but for a "Stop/Pause" we skip the game logic updates.
      }

      // Check for all-12 trigger
      if (window.arfrSettings.gameActive && archetypState === 'idle' && doomState === 'idle' && checkAllVesselsFilled()) {
        triggerArchetypEvent();
      }

      // Check for all-corrupted doom trigger
      if (window.arfrSettings.gameActive && doomState === 'idle' && archetypState === 'idle' && checkAllVesselsCorrupted()) {
        triggerDoomRitual();
      }

      // ── GENERATOR PHASES ──

      let generatorSpeed = 0;
      let pulseIntensity = 0;

      if (elapsed < 10) {
        // Phase 1: Pulsing — breathing glow, no spin
        const p = elapsed / 10; // 0 to 1
        pulseIntensity = 0.3 + 0.7 * Math.sin(elapsed * 1.5) * Math.sin(elapsed * 1.5);
        // Subtle wobble, not real rotation
        logoGroup.rotation.y = Math.sin(elapsed * 3) * 0.02 * p;
        generatorSpeed = 0;
      } else if (elapsed < 35) {
        // Phase 2: Accelerating spin
        const p = (elapsed - 10) / 25; // 0 to 1 over 25 seconds
        const eased = p * p * p; // cubic ease-in — slow start, fast end
        generatorSpeed = eased * 0.8;
        pulseIntensity = 0.5 + eased * 0.5;
      } else {
        // Phase 3: Full speed — so fast it's a blur
        generatorSpeed = 0.8 + Math.sin(time * 3) * 0.05; // slight variation
        // Archetyp override
        if (archetypSpeedOverride !== null) {
          generatorSpeed = archetypSpeedOverride;
        }
        pulseIntensity = 1;
      }

      // Smooth deceleration/acceleration for manual toggle
      if (logoRotationRequest) {
        logoRotationMul = Math.min(1, logoRotationMul + 0.015);
      } else {
        logoRotationMul = Math.max(0, logoRotationMul - 0.015);
      }
      generatorSpeed *= logoRotationMul;

      // Apply rotation based on final speed
      if (generatorSpeed > 0) {
        logoGroup.rotation.y -= generatorSpeed;
      }

      // Energy effects scale with speed and pulse
      const isFullBlackout = (doomState === 'blackout' || doomState === 'message');
      const darkMul = isFullBlackout ? 0 : Math.max(0, 1 - sceneDarkness); // 1 = normal, 0 = fully dark
      const glowBoost = (Math.max(pulseIntensity, generatorSpeed / 0.4) + archetypBlastIntensity) * darkMul;
      coreLight.intensity = isFullBlackout ? 0 : (0.2 + glowBoost * 1.5) * (doomState !== 'idle' ? Math.max(0.05, darkMul) : 1);
      coreLight.distance = 40 + archetypBlastIntensity * 60;
      coreLight.color.setHex(glowBoost > 0.6 ? AMBER_LIGHT : AMBER);
      chipEdge.material.opacity = isFullBlackout ? 0 : (0.1 + glowBoost * 0.5) * Math.max(0.1, darkMul);

      // Glow sprites — dim during doom, zero during blackout
      glowSprite.material.opacity = isFullBlackout ? 0 : Math.min(1, 0.1 + glowBoost * 0.4 + archetypBlastIntensity * 0.3) * Math.max(0.05, darkMul);
      glowSprite.scale.setScalar(10 + glowBoost * 8 + archetypBlastIntensity * 20);
      glowSprite2.material.opacity = isFullBlackout ? 0 : Math.min(1, 0.04 + glowBoost * 0.18 + archetypBlastIntensity * 0.4) * Math.max(0.05, darkMul);
      glowSprite2.scale.setScalar(18 + glowBoost * 10 + archetypBlastIntensity * 40);

      // Logo elements glow — dim during doom, zero during blackout
      const logoGlow = isFullBlackout ? 0 : Math.min(1, 0.7 + glowBoost * 0.3) * Math.max(0.08, darkMul);
      logoGroup.children.forEach(child => {
        if (child.material) child.material.opacity = logoGlow;
      });

      // Chip mesh opacity
      if (isFullBlackout) {
        chipMesh.material.opacity = 0;
      }

      // Dim starfield during doom, hide during blackout
      if (isFullBlackout) {
        starMat.uniforms.uOpacity.value = 0;
      } else if (doomState !== 'idle') {
        starMat.uniforms.uOpacity.value *= Math.max(0.03, darkMul);
      }

      // Dim ambient/directional lights during doom, zero during blackout
      dirLight.intensity = isFullBlackout ? 0 : 0.3 * Math.max(0.05, darkMul);
      scene.children.forEach(c => {
        if (c.isAmbientLight) c.intensity = isFullBlackout ? 0 : 0.8 * Math.max(0.05, darkMul);
      });

      // Hide UI buttons during doom cinema, restore after
      const isDoomCinema = (doomState === 'blackout' || doomState === 'message' || doomState === 'captivity' || doomState === 'archangels_enter' || doomState === 'archangels_battle' || doomState === 'healing' || doomState === 'archangels_leave');
      if (isFullBlackout || isDoomCinema) {
        document.getElementById('chat-trigger').style.opacity = '0';
        document.getElementById('info-trigger').style.opacity = '0';
        document.getElementById('settings-trigger').style.opacity = '0';
        document.getElementById('play-trigger').style.opacity = '0';
        document.getElementById('rabbit-trigger').style.opacity = '0';
        document.getElementById('msg-stack').style.opacity = '0';
        document.getElementById('score-hud').style.opacity = '0';
      } else if (doomState === 'idle' && window._doomIconsHidden) {
        // Restore icons after doom cinema ends
        document.getElementById('chat-trigger').style.opacity = '';
        document.getElementById('info-trigger').style.opacity = '';
        document.getElementById('settings-trigger').style.opacity = '';
        document.getElementById('play-trigger').style.opacity = '';
        document.getElementById('rabbit-trigger').style.opacity = '';
        document.getElementById('msg-stack').style.opacity = '';
        document.getElementById('score-hud').style.opacity = '';
        window._doomIconsHidden = false;
      }
      if (isDoomCinema) window._doomIconsHidden = true;

      // Sparks — only in phase 2+3, suppressed during doom
      const sparkChance = (generatorSpeed > 0.05 && doomState === 'idle') ? generatorSpeed * 0.5 : 0;
      if (Math.random() < sparkChance && sparks.length < 50) {
        emitSpark(glowBoost);
        if (generatorSpeed > 0.5) emitSpark(glowBoost);
        if (generatorSpeed > 0.7) emitSpark(glowBoost); // triple sparks at max
      }

      // Update sparks
      for (let i = sparks.length - 1; i >= 0; i--) {
        const s = sparks[i];
        s.mesh.position.x += s.vx;
        s.mesh.position.y += s.vy;
        s.mesh.position.z += s.vz;
        s.vy -= 0.0005; // slight gravity
        s.life -= s.decay;
        s.mesh.material.opacity = Math.max(0, s.life);
        if (s.mesh.children[0]) s.mesh.children[0].material.opacity = Math.max(0, s.life * 0.5);
        if (s.life <= 0) {
          coreGroup.remove(s.mesh);
          sparks.splice(i, 1);
        }
      }

      // ── HOLOGRAPHIC MESSAGES ──
      const msgInterval = elapsed < 30 ? 3 : MSG_INTERVAL;
      if (loadingDone && elapsed > 6 && !allMsgsDone && elapsed - lastMsgTime > msgInterval) {
        lastMsgTime = elapsed;
        emitMessage();
      }

      for (let i = pulses.length - 1; i >= 0; i--) {
        const p = pulses[i];

        if (!p.trace || p.trace.length < 2) {
          removePulseTrail(p); pulses.splice(i, 1); spawnPulse(); continue;
        }

        let moved = false;
        let attempts = 0;
        while (!moved && attempts < 20) {
          attempts++;
          if (p.segIdx >= p.trace.length - 1) {
            removePulseTrail(p); pulses.splice(i, 1); spawnPulse(); moved = true; break;
          }
          const from = p.trace[p.segIdx];
          const to = p.trace[p.segIdx + 1];
          if (!from || !to) { p.segIdx++; continue; }

          const segLen = from.distanceTo(to);
          if (segLen < 0.01) { p.segIdx++; p.t = 0; continue; }

          p.t += 0.2 / segLen;

          if (p.t >= 1) { p.t = 0; p.segIdx++; continue; }

          p.mesh.position.lerpVectors(from, to, p.t);
          const dist = Math.sqrt(p.mesh.position.x ** 2 + p.mesh.position.z ** 2);
          const fade = Math.max(0, 1 - dist / FADE_RADIUS);
          const doomFade = Math.max(0, 1 - sceneDarkness);
          p.mesh.material.opacity = fade * doomFade;
          if (p.mesh.children[0]) p.mesh.children[0].material.opacity = 0.15 * fade * doomFade;

          // Drop trail dot every 3 frames
          p.trailTimer++;
          if (p.trailTimer >= 3) {
            p.trailTimer = 0;
            const dot = p.trail[p.trailIdx % TRAIL_LEN];
            dot.position.copy(p.mesh.position);
            dot.visible = true;
            dot.material.opacity = fade * 0.6;
            if (dot.children[0]) dot.children[0].material.opacity = fade * 0.2;
            p.trailIdx++;
          }

          // Fade all trail dots
          for (let j = 0; j < TRAIL_LEN; j++) {
            const dot = p.trail[j];
            if (!dot.visible) continue;
            dot.material.opacity *= 0.92;
            if (dot.children[0]) dot.children[0].material.opacity *= 0.92;
            if (dot.material.opacity < 0.01) dot.visible = false;
          }

          moved = true;
        }
      }
      if (Math.random() > 0.95 && pulses.length < 100) spawnPulse();

renderer.render(scene, camera);
    }
    animate();

    // ══════════════════════════════════════════════════════
    //  SOUND SYSTEM - Web Audio API
    // ══════════════════════════════════════════════════════
    let audioCtx = null;
    let bgAudio = null;
    
    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      // Resume audio context if suspended
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    }
    
    function playBackgroundMusic() {
      if (bgAudio) return; // Already playing
      
      initAudio();
      bgAudio = new Audio('817144__craigsmith__nasa-walla.wav');
      bgAudio.volume = 1.0;
      bgAudio.play().catch(() => {});
}
    
    function playSound(type) {
      if (!audioCtx) return;
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);

      switch(type) {
        case 'catch': // Materia gefangen - hoher Glockenton
          osc.type = 'sine';
          osc.frequency.setValueAtTime(880, now);
          osc.frequency.exponentialRampToValueAtTime(1760, now + 0.1);
          gain.gain.setValueAtTime(0.15, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
          osc.start(now);
          osc.stop(now + 0.3);
          break;
        case 'demon': // Dämon besiegt - tieferer Knall
          osc.type = 'sawtooth';
          osc.frequency.setValueAtTime(150, now);
          osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
          gain.gain.setValueAtTime(0.1, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
          osc.start(now);
          osc.stop(now + 0.25);
          break;
        case 'fill': // Vessel gefüllt
          osc.type = 'triangle';
          osc.frequency.setValueAtTime(440, now);
          osc.frequency.setValueAtTime(554, now + 0.1);
          osc.frequency.setValueAtTime(659, now + 0.2);
          gain.gain.setValueAtTime(0.1, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
          osc.start(now);
          osc.stop(now + 0.4);
          break;
        case 'levelup': // Level Up
          osc.type = 'sine';
          osc.frequency.setValueAtTime(523, now);
          osc.frequency.setValueAtTime(659, now + 0.15);
          osc.frequency.setValueAtTime(784, now + 0.3);
          osc.frequency.setValueAtTime(1047, now + 0.45);
          gain.gain.setValueAtTime(0.12, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.7);
          osc.start(now);
          osc.stop(now + 0.7);
          break;
        case 'doom': // DOOM startet
          osc.type = 'sawtooth';
          osc.frequency.setValueAtTime(80, now);
          osc.frequency.exponentialRampToValueAtTime(30, now + 1.5);
          gain.gain.setValueAtTime(0.15, now);
          gain.gain.linearRampToValueAtTime(0.01, now + 1.5);
          osc.start(now);
          osc.stop(now + 1.5);
          break;
        case 'cleanse': // Vessel gereinigt
          osc.type = 'sine';
          osc.frequency.setValueAtTime(600, now);
          osc.frequency.exponentialRampToValueAtTime(1200, now + 0.15);
          gain.gain.setValueAtTime(0.1, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
          osc.start(now);
          osc.stop(now + 0.2);
          break;
        case 'click': // UI Click
          osc.type = 'sine';
          osc.frequency.setValueAtTime(1000, now);
          gain.gain.setValueAtTime(0.05, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
          osc.start(now);
          osc.stop(now + 0.05);
          break;
        case 'error': // Fehler/Warnung
          osc.type = 'square';
          osc.frequency.setValueAtTime(200, now);
          osc.frequency.setValueAtTime(150, now + 0.1);
          gain.gain.setValueAtTime(0.08, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
          osc.start(now);
          osc.stop(now + 0.2);
          break;
      }
    }

    // ══════════════════════════════════════════════════════════════
    //  WAKE LOCK – NoSleep.js keeps screen on
    // ══════════════════════════════════════════════════════
    let noSleepStarted = false;
    function initNoSleep() {
      if (noSleepStarted) return;
      noSleepStarted = true;
      try {
        const noSleep = new NoSleep();
        noSleep.enable();
      } catch (e) {}
    }
    document.addEventListener('click', initNoSleep, { once: false });
    document.addEventListener('touchstart', initNoSleep, { once: false });
    document.addEventListener('keydown', initNoSleep, { once: false });

    window.addEventListener('resize', () => {
      const a = window.innerWidth / window.innerHeight;
      camera.left = -viewSize * a + SHIFT_X;
      camera.right = viewSize * a + SHIFT_X;
      camera.top = viewSize + SHIFT_Y;
      camera.bottom = -viewSize + SHIFT_Y;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ══════════════════════════════════════════════════════
    //  INFO PANEL
    // ══════════════════════════════════════════════════════
    const infoTrigger = document.getElementById('info-trigger');
    const infoPanel = document.getElementById('info-panel');
    const infoClose = document.getElementById('info-close');
    let infoOpen = false;

    // Show info trigger after 40s (synced with chat trigger)
    setTimeout(() => infoTrigger.classList.add('visible'), 40000);

    infoTrigger.addEventListener('click', () => {
      infoOpen = !infoOpen;
      infoPanel.classList.toggle('open', infoOpen);
    });
    infoClose.addEventListener('click', () => {
      infoOpen = false;
      infoPanel.classList.remove('open');
    });

    // Prevent 3D drag when interacting with info panel
    infoPanel.addEventListener('mousedown', e => e.stopPropagation());
    infoPanel.addEventListener('touchstart', e => e.stopPropagation());
    infoPanel.addEventListener('wheel', e => e.stopPropagation(), { passive: false });
    infoTrigger.addEventListener('mousedown', e => e.stopPropagation());
    infoTrigger.addEventListener('touchstart', e => e.stopPropagation());

    // ══════════════════════════════════════════════════════
    //  SETTINGS PANEL
    // ══════════════════════════════════════════════════════
    const settingsTrigger = document.getElementById('settings-trigger');
    const settingsPanel = document.getElementById('settings-panel');
    const settingsClose = document.getElementById('settings-close');
    let settingsOpen = false;

    setTimeout(() => settingsTrigger.classList.add('visible'), 40000);

    settingsTrigger.addEventListener('click', () => {
      settingsOpen = !settingsOpen;
      settingsPanel.classList.toggle('open', settingsOpen);
    });
    settingsClose.addEventListener('click', () => {
      settingsOpen = false;
      settingsPanel.classList.remove('open');
    });

    // Toggle handlers
    document.getElementById('toggle-auto-cam').addEventListener('click', function () {
      this.classList.toggle('on');
      window.arfrSettings.autoCam = this.classList.contains('on');
    });
    document.getElementById('toggle-manual-cam').addEventListener('click', function () {
      this.classList.toggle('on');
      window.arfrSettings.manualCam = this.classList.contains('on');
    });
    document.getElementById('toggle-rotation-lock').addEventListener('click', function () {
      this.classList.toggle('on');
      const isOn = this.classList.contains('on');
      window.arfrSettings.rotationLock = isOn;
      if (isOn) {
        window.arfrSettings.lockedDragX = dragX;
        window.arfrSettings.lockedDragY = dragY;
      }
    });

    settingsPanel.addEventListener('mousedown', e => e.stopPropagation());
    settingsPanel.addEventListener('touchstart', e => e.stopPropagation());
    settingsPanel.addEventListener('wheel', e => e.stopPropagation(), { passive: false });
    settingsTrigger.addEventListener('mousedown', e => e.stopPropagation());
    settingsTrigger.addEventListener('touchstart', e => e.stopPropagation());

    // ── PLAY TRIGGER LOGIC ──
    const playTrigger = document.getElementById('play-trigger');
    const playIcon = document.getElementById('play-icon');
    const resetModal = document.getElementById('reset-modal');
    const resetCancel = document.getElementById('reset-cancel');
    const resetConfirm = document.getElementById('reset-confirm');

    function resetCore() {
      // 1. Clear Materia Orbs
      for (const orb of materiaOrbs) {
        if (orb.group.parent) orb.group.parent.remove(orb.group);
        orb.orbMat.dispose(); orb.glowMat.dispose();
        orb.orbTex.dispose(); orb.wispTex.dispose();
        orb.wisps.forEach(w => w.mat.dispose());
      }
      materiaOrbs.length = 0;

      // 2. Clear Vessels
      for (const key in materiaVessels) {
        const v = materiaVessels[key];
        world.remove(v.group);
        v.baseMat.dispose(); v.vesselTex.dispose();
        v.ringMat.dispose(); v.ring2.material.dispose();
        v.miniOrbTex.dispose();
        v.miniOrbs.forEach(mo => mo.mat.dispose());
        if (v.shieldMat) { v.shieldMat.dispose(); v.shieldTex.dispose(); }
        if (v.grayOrbTex) v.grayOrbTex.dispose();
        if (v.grayVesselTex) v.grayVesselTex.dispose();
      }
      for (const key in materiaVessels) delete materiaVessels[key];
      vesselCount = 0;

      // 3. Clear Beams
      for (const key in archetypBeams) {
        removeBeam(key);
      }

      // 4. Clear Demons
      for (const d of demons) {
        world.remove(d.group);
        d.orbMat.dispose(); d.auraMat.dispose(); d.orbTex.dispose();
      }
      demons.length = 0;

      // 5. Clear Transfer Anims
      for (const ta of transferAnimations) {
        world.remove(ta.sprite);
        ta.mat.dispose(); ta.tex.dispose();
      }
      transferAnimations.length = 0;

      // 6. Reset State
      archetypState = 'idle';
      archetypAge = 0;
      archetypSpeedOverride = null;
      archetypBlastIntensity = 0;

      // 7. Reset Doom Ritual
      cleanupDoomRitual();
      removeGlobalShield();
      doomState = 'idle';
      doomAge = 0;
      doomIntensity = 0;
      sceneDarkness = 0;
      doomVortexAngle = 0;
      totalInfections = 0;
      blastLevel = 0;
      coreGroup.position.y = 0.1;
      coreGroup._targetY = 0.1;
      world.position.y = 0;
      world.visible = true;
      coreGroup.visible = true;
      starField.visible = true;
      const doomOv = document.getElementById('doom-overlay');
      if (doomOv) doomOv.remove();

      // Reset Timers
      time = 0;
      nextMateriaTime = 10;
      nextDemonTime = 40;

      // UI Reset
      window.arfrSettings.gameActive = false;
      playIcon.innerHTML = '<polygon points="6.5 3 20.5 12 6.5 21 6.5 3"></polygon>';
      playTrigger.setAttribute('title', 'MATERIA START');
      
      // Reset Score & Hide HUD
      gameScore = 0;
      materiaCaught = 0;
      demonsKilled = 0;
      vesselsCleansed = 0;
      updateScoreHUD();
      hideScoreHUD();
      // Force hide on mobile
      document.getElementById('score-hud').style.display = 'none';
    }

    // Play button hidden until 3 logo clicks
    // setTimeout(() => playTrigger.classList.add('visible'), 40000); // Disabled: now requires 3 logo clicks

    // Logo click counter - show play button after 3 clicks
    let logoClickCount = 0;
    const LOGO_CLICKS_REQUIRED = 4;

    playTrigger.addEventListener('click', () => {
      playSound('click');
      if (window.arfrSettings.gameActive) {
        // Show confirmation before stopping/resetting
        resetModal.classList.add('visible');
      } else {
        // Start
        window.arfrSettings.gameActive = true;
        window.arfrSettings.autoCam = false; // Disable auto camera when game starts
        // Also update the toggle button visually
        const autoCamToggle = document.getElementById('toggle-auto-cam');
        if (autoCamToggle) autoCamToggle.classList.remove('on');
        playIcon.innerHTML = '<rect x="6" y="6" width="12" height="12" rx="1" />';
        playTrigger.setAttribute('title', 'Stop Materia');
        // Start background music
        playBackgroundMusic();
        // Immediately spawn first materia — set timer to 0 so next frame spawns
        nextMateriaTime = 0;
        showScoreHUD();
        // Keep screen awake on mobile
        initNoSleep();
      }
    });

    resetCancel.addEventListener('click', () => {
      resetModal.classList.remove('visible');
    });

    resetConfirm.addEventListener('click', () => {
      resetModal.classList.remove('visible');
      resetCore();
      // Force hide HUD immediately
      const hud = document.getElementById('score-hud');
      hud.style.display = 'none';
      hud.classList.remove('visible');
    });

    playTrigger.addEventListener('mousedown', e => e.stopPropagation());
    playTrigger.addEventListener('touchstart', e => e.stopPropagation());
    resetModal.addEventListener('mousedown', e => e.stopPropagation());
    resetModal.addEventListener('touchstart', e => e.stopPropagation());
    resetModal.addEventListener('wheel', e => e.stopPropagation(), { passive: false });

    // ══════════════════════════════════════════════════════
    //  WHITE RABBIT — Matrix Easter Egg
    // ══════════════════════════════════════════════════════
    const rabbitTrigger = document.getElementById('rabbit-trigger');
    let rabbitVisible = false;
    let rabbitTimer = null;
    let rabbitGameStarted = false;
    let rabbitClicked = false; // Track if user has clicked the rabbit

    function showRabbit() {
      // Only show if game is active and user hasn't clicked yet
      if (!window.arfrSettings.gameActive || rabbitClicked) return;
      if (rabbitVisible) return;
      rabbitVisible = true;
      rabbitTrigger.classList.add('visible');
      rabbitTrigger.classList.remove('ghost');

      // Stay visible for 3-8 seconds, then vanish
      const stayTime = 3000 + Math.random() * 5000;
      rabbitTimer = setTimeout(() => {
        hideRabbit();
      }, stayTime);
    }

    function hideRabbit() {
      rabbitVisible = false;
      rabbitTrigger.classList.remove('visible');
      rabbitTrigger.classList.add('ghost');
      if (rabbitTimer) { clearTimeout(rabbitTimer); rabbitTimer = null; }

      // Schedule next appearance: 15-60 seconds (only if game is still active)
      if (window.arfrSettings.gameActive && !rabbitClicked) {
        const nextTime = 15000 + Math.random() * 45000;
        setTimeout(() => showRabbit(), nextTime);
      }
    }

    // First appearance after 50-90 seconds (only if game is active)
    setTimeout(() => {
      if (window.arfrSettings.gameActive && !rabbitClicked) {
        showRabbit();
      }
    }, 50000 + Math.random() * 40000);

    rabbitTrigger.addEventListener('click', () => {
      if (!rabbitGameStarted) {
        rabbitGameStarted = true;
        rabbitClicked = true; // Never show again after successful click
        
        // Clear console and show the intro
        console.clear();

        console.log('%c' + `
 ╔══════════════════════════════════════════════════════════════╗
 ║                                                              ║
 ║              🐇  FOLLOW THE WHITE RABBIT  🐇                ║
 ║                                                              ║
 ╚══════════════════════════════════════════════════════════════╝
`, 'color: #64ff8a; font-family: monospace; font-size: 12px;');

        console.log('%c Wake up, Operator...', 'color: #64ff8a; font-size: 14px; font-weight: bold;');
        console.log('');
        console.log('%c The ARFR system has a hidden layer. You found the entry point.', 'color: #4aff7a; font-size: 11px;');
        console.log('%c This console is now your command terminal.', 'color: #4aff7a; font-size: 11px;');
        console.log('');
        console.log('%c ═══════════════════════════════════════════════', 'color: #3a6648;');
        console.log('%c  AVAILABLE COMMANDS:', 'color: #64ff8a; font-size: 12px; font-weight: bold;');
        console.log('%c ═══════════════════════════════════════════════', 'color: #3a6648;');
        console.log('');
        console.log('%c  rabbit.scan()       %c— Scan the current system state', 'color: #64ff8a; font-weight: bold;', 'color: #5a8a6a;');
        console.log('%c  rabbit.spawn(n)     %c— Force-spawn n materia orbs', 'color: #64ff8a; font-weight: bold;', 'color: #5a8a6a;');
        console.log('%c  rabbit.purge()      %c— Destroy all active demons', 'color: #64ff8a; font-weight: bold;', 'color: #5a8a6a;');
        console.log('%c  rabbit.corrupt(n)   %c— Summon n demons immediately', 'color: #64ff8a; font-weight: bold;', 'color: #5a8a6a;');
        console.log('%c  rabbit.heal()       %c— Cleanse all corrupted vessels', 'color: #64ff8a; font-weight: bold;', 'color: #5a8a6a;');
        console.log('%c  rabbit.doom()       %c— ⚠ Trigger the doom ritual', 'color: #ff6464; font-weight: bold;', 'color: #8a5a5a;');
        console.log('%c  rabbit.blast()      %c— ⚡ Force an archetyp blast', 'color: #ffcc64; font-weight: bold;', 'color: #8a7a4a;');
        console.log('%c  rabbit.shield()     %c— Activate blast shield', 'color: #64ccff; font-weight: bold;', 'color: #4a7a8a;');
        console.log('%c  rabbit.godmode()    %c— Shield all vessels', 'color: #64ff8a; font-weight: bold;', 'color: #5a8a6a;');
        console.log('%c  rabbit.speed(x)     %c— Set generator speed (0-5)', 'color: #64ff8a; font-weight: bold;', 'color: #5a8a6a;');
        console.log('%c  rabbit.level(n)     %c— Jump to blast level n', 'color: #64ff8a; font-weight: bold;', 'color: #5a8a6a;');
        console.log('%c  rabbit.fill()       %c— Fill all vessels to 3 materia', 'color: #64ff8a; font-weight: bold;', 'color: #5a8a6a;');
        console.log('%c  rabbit.noclip()     %c— Make shield invincible', 'color: #64ff8a; font-weight: bold;', 'color: #5a8a6a;');
        console.log('%c  rabbit.rave()       %c— Party mode', 'color: #ff64ff; font-weight: bold;', 'color: #8a4a8a;');
        console.log('%c  rabbit.victory()    %c— ★ Trigger the ending', 'color: #ffd700; font-weight: bold;', 'color: #8a7a2a;');
        console.log('%c  rabbit.matrix()     %c— ???', 'color: #64ff8a; font-weight: bold;', 'color: #3a6648;');
        console.log('%c  rabbit.help()       %c— Show this menu again', 'color: #64ff8a; font-weight: bold;', 'color: #5a8a6a;');
        console.log('');
        console.log('%c ═══════════════════════════════════════════════', 'color: #3a6648;');
        console.log('%c  "The Matrix has you..." — type rabbit.help() to begin', 'color: #3a6648; font-style: italic;');
        console.log('%c ═══════════════════════════════════════════════', 'color: #3a6648;');

      } else {
        console.log('%c 🐇 The rabbit watches...', 'color: #64ff8a; font-style: italic;');
        console.log('%c    Type rabbit.help() for commands', 'color: #4a8a5a;');
      }

      // Flash the button green
      rabbitTrigger.style.borderColor = 'rgba(100, 255, 140, 0.8)';
      rabbitTrigger.style.boxShadow = '0 0 25px rgba(100, 255, 140, 0.4)';
      setTimeout(() => {
        rabbitTrigger.style.borderColor = '';
        rabbitTrigger.style.boxShadow = '';
      }, 500);
    });

    // ── Rabbit Console API ──
    window.rabbit = {
      help() {
        console.clear();
        console.log('%c 🐇 RABBIT TERMINAL — COMMANDS:', 'color: #64ff8a; font-size: 13px; font-weight: bold;');
        console.log('%c  rabbit.scan()       — System state', 'color: #64ff8a;');
        console.log('%c  rabbit.spawn(n)     — Spawn n materia', 'color: #64ff8a;');
        console.log('%c  rabbit.purge()      — Kill all demons', 'color: #64ff8a;');
        console.log('%c  rabbit.corrupt(n)   — Summon n demons', 'color: #64ff8a;');
        console.log('%c  rabbit.heal()       — Cleanse all vessels', 'color: #64ff8a;');
        console.log('%c  rabbit.blast()      — Force blast', 'color: #ffcc64;');
        console.log('%c  rabbit.shield()     — Activate shield', 'color: #64ccff;');
        console.log('%c  rabbit.doom()       — ⚠ Trigger doom', 'color: #ff6464;');
        console.log('%c  rabbit.godmode()    — Shield all vessels', 'color: #64ff8a;');
        console.log('%c  rabbit.speed(x)     — Generator speed', 'color: #64ff8a;');
        console.log('%c  rabbit.level(n)     — Jump to level', 'color: #64ff8a;');
        console.log('%c  rabbit.fill()       — Fill all vessels', 'color: #64ff8a;');
        console.log('%c  rabbit.noclip()     — Invincible shield', 'color: #64ff8a;');
        console.log('%c  rabbit.rave()       — Party mode', 'color: #ff64ff;');
        console.log('%c  rabbit.victory()    — ★ Trigger ending', 'color: #ffd700;');
        console.log('%c  rabbit.matrix()     — ???', 'color: #64ff8a;');
      },

      scan() {
        const vesselList = Object.values(materiaVessels);
        const corrupted = vesselList.filter(v => v.corrupted).length;
        const shielded = vesselList.filter(v => v.shielded).length;
        const totalMateria = vesselList.reduce((sum, v) => sum + v.count, 0);

        console.log('%c ╔══ SYSTEM SCAN ══════════════════════════╗', 'color: #64ff8a;');
        console.log(`%c  Vessels:    ${vesselList.length}/12`, 'color: #64ff8a;');
        console.log(`%c  Corrupted:  ${corrupted}`, corrupted > 0 ? 'color: #ff6464;' : 'color: #64ff8a;');
        console.log(`%c  Shielded:   ${shielded}`, 'color: #64ccff;');
        console.log(`%c  Materia:    ${totalMateria} total`, 'color: #64ff8a;');
        console.log(`%c  Demons:     ${demons.length} active`, demons.length > 0 ? 'color: #ff6464;' : 'color: #64ff8a;');
        console.log(`%c  Orbs:       ${materiaOrbs.length} floating`, 'color: #64ff8a;');
        console.log(`%c  Archetyp:   ${archetypState}`, 'color: #64ff8a;');
        console.log(`%c  Doom:       ${doomState}`, doomState !== 'idle' ? 'color: #ff6464;' : 'color: #64ff8a;');
        console.log(`%c  Victory:    ${victoryState}`, victoryState !== 'idle' ? 'color: #ffd700;' : 'color: #64ff8a;');
        console.log(`%c  Level:      ${blastLevel}/10`, blastLevel >= 10 ? 'color: #ffd700; font-weight: bold;' : 'color: #64ff8a;');
        console.log(`%c  Shield:     ${globalShield ? globalShield.hp + ' HP' : 'inactive'}`, globalShield ? 'color: #64ccff;' : 'color: #64ff8a;');
        console.log(`%c  Infections: ${totalInfections}`, 'color: #ffaa64;');
        console.log(`%c  Game:       ${window.arfrSettings.gameActive ? 'ACTIVE' : 'STOPPED'}`, 'color: #64ff8a;');
        console.log('%c ╚═════════════════════════════════════════╝', 'color: #64ff8a;');
      },

      spawn(n = 1) {
        if (!window.arfrSettings.gameActive) {
          console.log('%c ⚠ Game is not active. Press Play first.', 'color: #ffaa64;');
          return;
        }
        n = Math.min(20, Math.max(1, Math.floor(n)));
        for (let i = 0; i < n; i++) createMateriaOrb();
        console.log(`%c 🐇 Spawned ${n} materia orb${n > 1 ? 's' : ''}`, 'color: #64ff8a;');
      },

      purge() {
        const count = demons.length;
        for (let i = demons.length - 1; i >= 0; i--) {
          const d = demons[i];
          world.remove(d.group);
          d.orbMat.dispose(); d.auraMat.dispose(); d.orbTex.dispose();
          if (d.lightnings) {
            d.lightnings.forEach(l => {
              d.group.remove(l.line);
              l.line.geometry.dispose();
              l.line.material.dispose();
            });
          }
        }
        demons.length = 0;
        console.log(`%c 🐇 Purged ${count} demon${count !== 1 ? 's' : ''}. The field is clean.`, 'color: #64ff8a;');
      },

      corrupt(n = 1) {
        if (!window.arfrSettings.gameActive) {
          console.log('%c ⚠ Game is not active. Press Play first.', 'color: #ffaa64;');
          return;
        }
        n = Math.min(13, Math.max(1, Math.floor(n)));
        for (let i = 0; i < n; i++) createDemonOrb();
        console.log(`%c 🐇 Summoned ${n} demon${n > 1 ? 's' : ''}. Darkness stirs...`, 'color: #ff6464;');
      },

      heal() {
        let healed = 0;
        for (const key in materiaVessels) {
          const v = materiaVessels[key];
          if (!v.corrupted) continue;
          v.corrupted = false;
          v.demonCount = 0;
          if (v.lightnings) {
            v.lightnings.forEach(l => {
              v.group.remove(l.line);
              l.line.geometry.dispose();
              l.line.material.dispose();
            });
            v.lightnings = null;
          }
          v.baseMat.color = new THREE.Color(1, 1, 1);
          v.ringMat.color.copy(v.color);
          v.ring2.material.color.copy(v.color);
          v.vLight.color.copy(v.color);
          healed++;
        }
        console.log(`%c 🐇 Cleansed ${healed} vessel${healed !== 1 ? 's' : ''}. Light restored.`, 'color: #64ff8a;');
      },

      doom() {
        if (doomState !== 'idle') {
          console.log('%c ⚠ Doom is already in progress...', 'color: #ff6464;');
          return;
        }
        // Corrupt all existing vessels first
        for (const key in materiaVessels) {
          const v = materiaVessels[key];
          if (!v.corrupted) corruptVessel(v);
        }
        if (Object.keys(materiaVessels).length >= 12) {
          triggerDoomRitual();
          console.log('%c 🐇 ⚠ DOOM RITUAL TRIGGERED. There is no going back.', 'color: #ff3333; font-size: 14px; font-weight: bold;');
        } else {
          console.log(`%c ⚠ Only ${Object.keys(materiaVessels).length}/12 vessels exist. Corrupted all, but doom requires 12.`, 'color: #ffaa64;');
        }
      },

      godmode() {
        let shielded = 0;
        for (const key in materiaVessels) {
          const v = materiaVessels[key];
          if (!v.shielded && !v.corrupted) {
            applyShield(v);
            shielded++;
          }
        }
        console.log(`%c 🐇 Shielded ${shielded} vessel${shielded !== 1 ? 's' : ''}. Nothing can touch them now.`, 'color: #64ccff;');
      },

      speed(x = 1) {
        x = Math.max(0, Math.min(5, parseFloat(x)));
        archetypSpeedOverride = x;
        console.log(`%c 🐇 Generator speed → ${x.toFixed(1)}`, 'color: #64ff8a;');
        if (x === 0) console.log('%c    The core falls silent...', 'color: #5a8a6a; font-style: italic;');
        if (x > 3) console.log('%c    ⚠ Dangerously fast. Sparks everywhere.', 'color: #ffaa64; font-style: italic;');
      },

      matrix() {
        console.clear();
        const lines = [
          '                                                    ',
          '  Wake up, Neo...                                   ',
          '  The Matrix has you...                             ',
          '  Follow the white rabbit.                          ',
          '                                                    ',
          '  Knock, knock.                                     ',
          '                                                    ',
        ];
        lines.forEach((line, i) => {
          setTimeout(() => {
            console.log(`%c${line}`, 'color: #64ff8a; font-size: 14px; font-family: monospace; background: #000; padding: 2px 8px;');
          }, i * 800);
        });
        setTimeout(() => {
          console.log('');
          console.log('%c  "I know why you\'re here. You\'re looking for the answer.', 'color: #3a6648; font-style: italic;');
          console.log('%c   The answer is out there. It\'s looking for you.', 'color: #3a6648; font-style: italic;');
          console.log('%c   And it will find you... if you want it to."', 'color: #3a6648; font-style: italic;');
          console.log('');
          console.log('%c  Type rabbit.scan() to see the truth.', 'color: #4a8a5a;');
        }, lines.length * 800);
      },

      blast() {
        if (archetypState !== 'idle') {
          console.log('%c ⚠ Archetyp event already in progress', 'color: #ffaa64;');
          return;
        }
        triggerArchetypEvent();
        console.log('%c 🐇 ⚡ BLAST OVERRIDE — Archetyp event triggered!', 'color: #ffcc64; font-size: 13px; font-weight: bold;');
      },

      shield() {
        if (globalShield) {
          console.log('%c ⚠ Shield already active', 'color: #ffaa64;');
          return;
        }
        createGlobalShield();
        console.log('%c 🐇 🛡 Shield sphere activated — 5 charges', 'color: #64ccff;');
      },

      level(n = 1) {
        n = Math.max(1, Math.min(10, Math.floor(n)));
        blastLevel = n;
        const newY = 0.1 + n * 4;
        coreGroup._targetY = newY;
        coreGroup.position.y = newY;
        for (const key in materiaVessels) {
          materiaVessels[key].group.position.y = 1.5 + n * 4;
        }
        console.log(`%c 🐇 Jumped to level ${n}. Chip at Y=${newY.toFixed(1)}`, 'color: #64ff8a;');
        if (n >= 10) console.log('%c    ★ You are at the FINAL level!', 'color: #ffd700; font-weight: bold;');
      },

      fill() {
        let filled = 0;
        for (const key in materiaVessels) {
          const v = materiaVessels[key];
          while (v.count < 3) {
            v.count++;
            filled++;
          }
        }
        console.log(`%c 🐇 Filled vessels with ${filled} materia. All at max.`, 'color: #64ff8a;');
        if (checkAllVesselsFilled()) {
          console.log('%c    ⚡ All vessels full — blast conditions met!', 'color: #ffcc64; font-weight: bold;');
        }
      },

      noclip() {
        if (!globalShield) {
          createGlobalShield();
        }
        globalShield.hp = 999999;
        console.log('%c 🐇 NOCLIP — Shield is now invincible (999999 HP)', 'color: #64ff8a; font-weight: bold;');
      },

      rave() {
        console.log('%c 🐇 🎵 RAVE MODE ACTIVATED', 'color: #ff64ff; font-size: 14px; font-weight: bold;');
        let raveInterval = setInterval(() => {
          if (!window.arfrSettings.gameActive) { clearInterval(raveInterval); return; }
          for (const key in materiaVessels) {
            const v = materiaVessels[key];
            v.vLight.color.setHSL(Math.random(), 1, 0.6);
            v.vLight.intensity = 2 + Math.random() * 3;
            v.ringMat.color.setHSL(Math.random(), 0.9, 0.5);
          }
          coreLight.color.setHSL(Math.random(), 0.8, 0.6);
          coreLight.intensity = 1 + Math.random() * 3;
        }, 100);
        setTimeout(() => {
          clearInterval(raveInterval);
          coreLight.color.setHex(0xf0d2a0);
          coreLight.intensity = 0.5;
          for (const key in materiaVessels) {
            const v = materiaVessels[key];
            v.vLight.color.copy(v.color);
            v.ringMat.color.copy(v.color);
          }
          console.log('%c 🐇 Rave over. Back to business.', 'color: #ff64ff;');
        }, 10000);
      },

      victory() {
        if (victoryState !== 'idle') {
          console.log('%c ⚠ Victory already in progress', 'color: #ffaa64;');
          return;
        }
        blastLevel = 10;
        triggerVictory();
        console.log('%c 🐇 ★ VICTORY TRIGGERED — Enjoy the show!', 'color: #ffd700; font-size: 14px; font-weight: bold;');
      },
    };

    // Prevent 3D drag
    rabbitTrigger.addEventListener('mousedown', e => e.stopPropagation());
    rabbitTrigger.addEventListener('touchstart', e => e.stopPropagation());

    // ══════════════════════════════════════════════════════
    //  TELEGRAM CHAT BOT
    // ══════════════════════════════════════════════════════
    //  KONFIGURATION: Token und Chat-ID hier anpassen
    //  BOT_TOKEN     = Telegram Bot Token von @BotFather
    //  ADMIN_CHAT    = Deine persönliche Telegram Chat-ID (Empfänger)
    //  POLL_INTERVAL = Sekunden zwischen Polling-Abfragen

    const ADMIN_CHAT = '5741725666';
    const POLL_INTERVAL = 3;
	const TG_API = 'https://inot.app/api/telegram/proxy';

    const chatTrigger = document.getElementById('chat-trigger');
    const chatPanel = document.getElementById('chat-panel');
    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const chatSend = document.getElementById('chat-send');
    const chatClose = document.getElementById('chat-close');

    let chatOpen = false;
    let chatSessionId = null;
    let lastUpdateId = 0;
    let pollTimer = null;
    let chatInitialized = false;

    // Show trigger button after 40s (synced with camera start)
    setTimeout(() => {
      chatTrigger.classList.add('visible');
      chatTrigger.classList.add('pulse'); // Subtle hint instead of auto-opening
    }, 40000);

    function addBubble(text, type) {
      const el = document.createElement('div');
      el.className = 'chat-bubble ' + type;
      el.textContent = text;
      chatMessages.appendChild(el);
      chatMessages.scrollTop = chatMessages.scrollHeight;

      // Auto-open if closed and message is not from user
      if (!chatOpen && type !== 'chat-user') {
        chatOpen = true;
        chatPanel.classList.add('open');
        initChat();
      }
    }

    function generateSessionId() {
      return 'web_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2, 6);
    }

    let sentMsgIds = new Set(); // track our own message IDs

    async function sendToTelegram(message) {
		try {
			const res = await fetch(TG_API, {
			  method: 'POST',
			  headers: { 'Content-Type': 'application/json' },
			  body: JSON.stringify({
				method: 'sendMessage',
				params: {
				  chat_id: ADMIN_CHAT,
				  text: `🌐 [${chatSessionId}]\n${message}`,
				  parse_mode: 'HTML'
				}
			  })
			});
			if (res.ok) {
			  const data = await res.json();
			  if (data.ok && data.result) sentMsgIds.add(data.result.message_id);
			}
			return res.ok;
		} catch (e) {
			console.error('Proxy error:', e);
			return false;
		}
    }

	let isPolling = false;

    async function pollForReplies() {
	
		if (isPolling) return; // Verhindert doppeltes Polling
		isPolling = true;
  
		try {
			const res = await fetch(TG_API, {
			  method: 'POST',
			  headers: { 'Content-Type': 'application/json' },
			  body: JSON.stringify({
				method: 'getUpdates',
				params: {
				  offset: lastUpdateId + 1,
				  timeout: 20
				}
			  })
			});

			if (!res.ok) return;
			
			const data = await res.json();
			
			if (!data.ok || !data.result) return;
			
			for (const update of data.result) {
			  lastUpdateId = update.update_id;

			  const msg = update.message;
			  
			  console.log(msg)
			  
			  if (!msg || !msg.text) continue;

			  // Nur Nachrichten vom Admin (deinem Chat) anzeigen
			  if (String(msg.chat.id) !== ADMIN_CHAT) continue;
			  
			  // Eigene gesendete Nachrichten überspringen
			  if (msg.text.startsWith('🌐')) continue;

			  // 1. Antwort auf eine unserer Nachrichten
			  if (msg.reply_to_message && sentMsgIds.has(msg.reply_to_message.message_id)) {
				
				if (!parseTelegramMessages(msg.text) && !parseCameraCommand(msg.text)) {
				  addBubble(msg.text, 'chat-bot');
				}
			  }

			  // 2. Direkte Nachricht mit Session-ID
			  if (msg.text.includes(chatSessionId)) {
				if (msg.text.includes(':message]')) parseTelegramMessages(msg.text);
				if (msg.text.includes(':camera]')) parseCameraCommand(msg.text);
			  }
			}
		  } catch (e) {
			console.error('Telegram poll error:', e);
		  }finally {
			isPolling = false;
			// Wichtig: Erst wenn der Request fertig ist, planen wir den nächsten in 1 Sekunde
			if (chatOpen) { 
			  setTimeout(initChat, 1000); 
			}
		  }
    }

    function startPolling() {
      if (pollTimer) return;
      pollTimer = setInterval(pollForReplies, POLL_INTERVAL * 1000);
    }

    async function initChat() {
		if (chatInitialized) return;
		chatInitialized = true;
		chatSessionId = generateSessionId();

		addBubble('COMM CHANNEL ACTIVE', 'chat-system');
		addBubble('Connection established. Your message will be forwarded.', 'chat-system');

		// Notify admin (über Proxy)
		await sendToTelegram('📡 New communication channel opened');

		// Get current offset to skip old messages → jetzt über den Proxy
		try {
		const res = await fetch(TG_API, {
		  method: 'POST',
		  headers: { 'Content-Type': 'application/json' },
		  body: JSON.stringify({
			method: 'getUpdates',
			params: {
			  offset: -1   // wichtig: offset -1 holt die neueste Nachricht
			}
		  })
		});

		const data = await res.json();

		if (data.ok && data.result && data.result.length > 0) {
		  lastUpdateId = data.result[data.result.length - 1].update_id;
		}
		} catch (e) {
		console.error('Failed to get initial offset from proxy:', e);
		}

		startPolling();
    }

    async function handleSend() {
      const text = chatInput.value.trim();
      if (!text) return;
      chatInput.value = '';
      addBubble(text, 'chat-user');
      const ok = await sendToTelegram(text);
      if (!ok) addBubble('TRANSMISSION ERROR', 'chat-system');
    }

    chatTrigger.addEventListener('click', () => {
      chatOpen = !chatOpen;
      chatPanel.classList.toggle('open', chatOpen);
      if (chatOpen) {
        chatTrigger.classList.remove('pulse');
        initChat();
        chatInput.focus();
      }
    });
    chatClose.addEventListener('click', () => {
      chatOpen = false;
      chatPanel.classList.remove('open');
    });
    chatSend.addEventListener('click', handleSend);
    chatInput.addEventListener('keydown', e => { if (e.key === 'Enter') handleSend(); });

    // Prevent 3D drag when interacting with chat
    chatPanel.addEventListener('mousedown', e => e.stopPropagation());
    chatPanel.addEventListener('touchstart', e => e.stopPropagation());
    // Prevent 3D zoom when scrolling chat
    chatPanel.addEventListener('wheel', e => e.stopPropagation(), { passive: false });
    chatTrigger.addEventListener('mousedown', e => e.stopPropagation());
    chatTrigger.addEventListener('touchstart', e => e.stopPropagation());

    chatTrigger.addEventListener('touchstart', e => e.stopPropagation());

    console.log("%c ARFR IDENT v2.0 %c System Ready...", "color: #c8aa78; font-weight: bold;", "color: grey;");
  </script>
</body>

</html>